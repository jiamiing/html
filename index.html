<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web 技术炫技展示 | 最前沿的网页特效</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 25%, #0f3460 50%, #533483 75%, #7209b7 100%);
            color: #fff;
            overflow-x: hidden;
        }

        /* Hero 区域 */
        .hero {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .hero-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .hero-content {
            position: relative;
            z-index: 10;
            text-align: center;
            pointer-events: none;
        }

        .hero-title {
            font-family: 'Technonomicon', Arial, sans-serif;
            font-size: clamp(2rem, 5.33vw, 5.33rem);
            font-weight: 900;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffeaa7);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
            margin-bottom: 1rem;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
        }

        .hero-subtitle {
            font-size: clamp(1.2rem, 3vw, 2rem);
            opacity: 0.8;
            margin-bottom: 2rem;
            letter-spacing: 2px;
        }

        @font-face {
            font-family: 'Pixely';
            src: url('./fonts/pixely.ttf') format('truetype');
            font-display: swap;
        }

        @font-face {
            font-family: 'Technonomicon';
            src: url('./fonts/Technonomicon.ttf') format('truetype');
            font-display: swap;
        }

        .terminal-text {
            font-family: 'Pixely', 'Courier New', 'Monaco', 'Menlo', monospace;
            color: #00ff00 !important;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 5px;
            text-shadow: 0 0 10px #00ff00;
            letter-spacing: 1px;
            font-weight: bold;
            border: 1px solid #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            animation: textFlicker 2s infinite;
        }

        .cursor {
            animation: blink 0.8s infinite;
            color: #00ff00;
            background-color: #00ff00;
            display: inline-block;
            width: 12px;
            height: 0.8em;
            margin-left: 2px;
            vertical-align: baseline;
        }

        .signature {
            position: absolute;
            top: 20px;
            right: 20px;
            font-family: 'Pixely', monospace;
            font-size: 14px;
            color: #00ff00;
            text-decoration: none;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 3px;
            text-shadow: 0 0 10px #00ff00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
            animation: signatureFlicker 0.3s infinite;
            transition: all 0.2s ease;
            z-index: 1000;
        }

        .signature:hover {
            background-color: rgba(0, 255, 0, 0.1);
            box-shadow: 0 0 25px rgba(0, 255, 0, 0.5);
            transform: scale(1.05);
        }

        @keyframes signatureFlicker {
            0%, 100% {
                opacity: 1;
                text-shadow: 0 0 10px #00ff00;
            }
            25% {
                opacity: 0.8;
                text-shadow: 0 0 5px #00ff00;
            }
            50% {
                opacity: 0.9;
                text-shadow: 0 0 15px #00ff00;
            }
            75% {
                opacity: 0.7;
                text-shadow: 0 0 8px #00ff00;
            }
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        @keyframes textFlicker {
            0%, 98% { 
                opacity: 1;
                text-shadow: 0 0 10px #00ff00;
            }
            99% { 
                opacity: 0.95;
                text-shadow: 0 0 8px #00ff00;
            }
            100% { 
                opacity: 0.98;
                text-shadow: 0 0 12px #00ff00;
            }
        }

        /* 内容流区域 */
        .content-flow {
            position: relative;
            z-index: 5;
            min-height: 100vh;
        }

        /* 液态文字交互演示 */
        .liquid-text-section {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            background: #180525;
        }

        .liquid-bg-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            filter: blur(25px);
            opacity: 0.9;
        }

        #liquid-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        .liquid-text-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1;
            pointer-events: none;
        }

        .liquid-text {
            font-family: 'Technonomicon', monospace;
            font-size: clamp(4rem, 12vw, 12rem);
            font-weight: bold;
            color: #ffffff;
            text-align: center;
            line-height: 1.2;
            letter-spacing: 0.1em;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* 动画 */
        @keyframes gradientShift {
            0%, 100% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateX(-50%) translateY(0);
            }
            40% {
                transform: translateX(-50%) translateY(-10px);
            }
            60% {
                transform: translateX(-50%) translateY(-5px);
            }
        }

        @keyframes colorShift {
            0%, 100% {
                transform: translate(0, 0) rotate(0deg);
                filter: hue-rotate(0deg) saturate(1) brightness(1);
            }
            20% {
                transform: translate(-3%, 2%) rotate(0.5deg);
                filter: hue-rotate(15deg) saturate(1.1) brightness(1.05);
            }
            40% {
                transform: translate(2%, -2%) rotate(-0.3deg);
                filter: hue-rotate(30deg) saturate(1.2) brightness(0.95);
            }
            60% {
                transform: translate(-1%, 3%) rotate(0.2deg);
                filter: hue-rotate(45deg) saturate(1.15) brightness(1.1);
            }
            80% {
                transform: translate(3%, -1%) rotate(-0.4deg);
                filter: hue-rotate(60deg) saturate(1.05) brightness(0.9);
            }
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            .hero-title {
                font-size: 3rem;
            }
            
            .hero-subtitle {
                font-size: 1.2rem;
            }
            
            .section {
                padding: 60px 15px;
            }
        }
    </style>
</head>
<body>
    <!-- Hero 区域 -->
    <section class="hero" id="hero">
        <canvas class="hero-canvas" id="heroCanvas"></canvas>
        <a href="https://open.spotify.com/track/3DK6m7It6Pw857FcQftMds?si=2577d4c1e3304221" target="_blank" class="signature">Kanye East</a>
        <div class="hero-content">
            <h1 class="hero-title">TUTORIALS</h1>
            <p class="hero-subtitle terminal-text" id="terminalSubtitle">VIBING CODING<span class="cursor">_</span></p>
        </div>

    </section>

    <!-- 后续内容区域 -->
    <main class="content-flow">
        <!-- 液态文字交互演示 -->
        <section class="liquid-text-section">
            <canvas class="liquid-bg-canvas" id="liquidBgCanvas"></canvas>
            <canvas id="liquid-canvas"></canvas>
            <div class="liquid-text-container">
                <div class="liquid-text" id="liquidText">DISSOLVE YOURSELF</div>
            </div>
        </section>
    </main>

    <!-- 引入必要的库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="./cannon.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    
    <script>
        // 注册GSAP插件
        gsap.registerPlugin(ScrollTrigger);
        
        // 终端打字效果
        function initTerminalEffect() {
            const subtitle = document.getElementById('terminalSubtitle');
            const baseText = 'VIBING CODING';
            let gCount = 0;
            let isAdding = true;
            let lastUpdate = 0;
            
            function updateTerminal() {
                const now = Date.now();
                if (now - lastUpdate < 300) return; // 控制打字速度
                lastUpdate = now;
                
                if (isAdding) {
                    gCount++;
                    if (gCount >= 8) {
                        isAdding = false;
                        setTimeout(() => {
                            isAdding = false;
                        }, 1000); // 停顿1秒后开始删除
                    }
                } else {
                    gCount--;
                    if (gCount <= 0) {
                        isAdding = true;
                        gCount = 0;
                    }
                }
                
                const gString = 'G'.repeat(Math.max(0, gCount));
                subtitle.innerHTML = baseText + gString + '<span class="cursor"></span>';
            }
            
            setInterval(updateTerminal, 300);
        }

        // 初始化应用
        document.addEventListener('DOMContentLoaded', function() {
            initHeroScene();
            initScrollAnimations();
            initTerminalEffect();
        });

        // Hero区域3D场景初始化
        function initHeroScene() {
            const canvas = document.getElementById('heroCanvas');
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                alpha: true, 
                antialias: true,
                powerPreference: "high-performance"
            });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            // 初始化物理世界
             const world = new CANNON.World();
             world.gravity.set(0, -4.9, 0); // 降低重力
             world.broadphase = new CANNON.NaiveBroadphase();
             world.defaultContactMaterial.friction = 0.4;
             world.defaultContactMaterial.restitution = 0.6; // 降低弹性
            
            // 创建边界墙体
             const boundaries = [];
             
             // 地面
             const groundShape = new CANNON.Plane();
             const groundBody = new CANNON.Body({ mass: 0 });
             groundBody.addShape(groundShape);
             groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
             groundBody.position.set(0, -8, 0);
             world.add(groundBody);
             boundaries.push(groundBody);
             
             // 左右墙
             const leftWall = new CANNON.Body({ mass: 0 });
             leftWall.addShape(new CANNON.Plane());
             leftWall.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI / 2);
             leftWall.position.set(-12, 0, 0);
             world.add(leftWall);
             
             const rightWall = new CANNON.Body({ mass: 0 });
             rightWall.addShape(new CANNON.Plane());
             rightWall.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2);
             rightWall.position.set(12, 0, 0);
             world.add(rightWall);
             
             // 前后墙
             const frontWall = new CANNON.Body({ mass: 0 });
             frontWall.addShape(new CANNON.Plane());
             frontWall.position.set(0, 0, -12);
             world.add(frontWall);
             
             const backWall = new CANNON.Body({ mass: 0 });
             backWall.addShape(new CANNON.Plane());
             backWall.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI);
             backWall.position.set(0, 0, 12);
             world.add(backWall);
             
             // 天花板
             const ceilingShape = new CANNON.Plane();
             const ceilingBody = new CANNON.Body({ mass: 0 });
             ceilingBody.addShape(ceilingShape);
             ceilingBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
             ceilingBody.position.set(0, 15, 0);
             world.add(ceilingBody);
            
            // 存储所有物体
            const objects = [];
            const bodies = [];
            const floatingObjects = [];
            const floatingBodies = [];
            const floatingOriginalPositions = [];
            
            // 创建25个几何体，增加不规则形状比例
             const geometries = [
                 new THREE.TorusKnotGeometry(0.8, 0.3, 128, 32, 2, 3),
                 new THREE.TorusKnotGeometry(0.7, 0.25, 128, 32, 3, 4),
                 new THREE.TorusKnotGeometry(0.9, 0.35, 128, 32, 5, 2),
                 new THREE.TorusKnotGeometry(0.6, 0.2, 128, 32, 4, 5),
                 new THREE.TorusKnotGeometry(0.85, 0.3, 128, 32, 3, 7),
                 new THREE.OctahedronGeometry(1.2, 6),
                 new THREE.IcosahedronGeometry(1.2, 6),
                 new THREE.DodecahedronGeometry(1.2, 6),
                 new THREE.TetrahedronGeometry(1.5, 6),
                 new THREE.TorusGeometry(1, 0.4, 64, 128),
                 new THREE.TorusGeometry(0.8, 0.3, 64, 128),
                 new THREE.TorusGeometry(1.2, 0.5, 64, 128),
                 new THREE.SphereGeometry(1, 128, 128),
                 new THREE.BoxGeometry(1.5, 1.5, 1.5, 32, 32, 32),
                 new THREE.ConeGeometry(1, 2, 128),
                 new THREE.CylinderGeometry(0.8, 0.8, 2, 128),
                 new THREE.OctahedronGeometry(1.0, 5),
                 new THREE.IcosahedronGeometry(1.0, 5),
                 new THREE.DodecahedronGeometry(1.0, 5),
                 new THREE.TetrahedronGeometry(1.3, 5),
                 new THREE.TorusKnotGeometry(0.75, 0.28, 128, 32, 6, 3),
                 new THREE.TorusKnotGeometry(0.65, 0.22, 128, 32, 7, 4),
                 new THREE.TorusKnotGeometry(0.95, 0.38, 128, 32, 2, 5),
                 new THREE.TorusGeometry(0.9, 0.35, 64, 128),
                 new THREE.SphereGeometry(0.8, 128, 128)
             ];
            
            // 创建超高质感Blender风格材质
             function createBlenderMaterial(color, metalness = 0.9, roughness = 0.1) {
                 return new THREE.MeshStandardMaterial({
                     color: color,
                     metalness: metalness,
                     roughness: roughness,
                     envMapIntensity: 2.5,
                     transparent: true,
                     opacity: 0.98,
                     clearcoat: 0.5,
                     clearcoatRoughness: 0.05,
                     sheen: 0.3,
                     sheenRoughness: 0.2,
                     sheenColor: new THREE.Color(0.2, 0.2, 0.3)
                 });
             }
            
            // 创建地面物体（原有的25个）
             for (let i = 0; i < 25; i++) {
                 const geometry = geometries[i];
                 const hue = (i / 25) * 360;
                 const material = createBlenderMaterial(
                     new THREE.Color().setHSL(hue / 360, 0.8, 0.6),
                     Math.random() * 0.2 + 0.8,
                     Math.random() * 0.15 + 0.05
                 );
                 
                 const mesh = new THREE.Mesh(geometry, material);
                 mesh.position.set(
                     (Math.random() - 0.5) * 10,
                     Math.random() * 6 + 3,
                     (Math.random() - 0.5) * 10
                 );
                 mesh.castShadow = true;
                 mesh.receiveShadow = true;
                 mesh.userData = { originalY: mesh.position.y, isHovered: false, isFloating: false };
                 scene.add(mesh);
                 objects.push(mesh);
                 
                 // 创建对应的物理体（增大尺寸）
                 const physicsShapes = [
                     new CANNON.Sphere(0.8),  // TorusKnot用球体近似
                     new CANNON.Sphere(0.7),
                     new CANNON.Sphere(0.9),
                     new CANNON.Sphere(0.6),
                     new CANNON.Sphere(0.85),
                     new CANNON.Sphere(1.2),  // Octahedron
                     new CANNON.Sphere(1.2),  // Icosahedron
                     new CANNON.Sphere(1.2),  // Dodecahedron
                     new CANNON.Sphere(1.5),  // Tetrahedron
                     new CANNON.Sphere(1),    // Torus
                     new CANNON.Sphere(0.8),
                     new CANNON.Sphere(1.2),
                     new CANNON.Sphere(1),    // Sphere
                     new CANNON.Box(new CANNON.Vec3(0.75, 0.75, 0.75)), // Box
                     new CANNON.Cylinder(1, 1, 2, 8), // Cone
                     new CANNON.Cylinder(0.8, 0.8, 2, 8), // Cylinder
                     new CANNON.Sphere(1.0),
                     new CANNON.Sphere(1.0),
                     new CANNON.Sphere(1.0),
                     new CANNON.Sphere(1.3),
                     new CANNON.Sphere(0.75),
                     new CANNON.Sphere(0.65),
                     new CANNON.Sphere(0.95),
                     new CANNON.Sphere(0.9),
                     new CANNON.Sphere(0.8)
                 ];
                 const shape = physicsShapes[i];
                 
                 const body = new CANNON.Body({ mass: 2 }); // 增加质量
                 body.addShape(shape);
                 body.position.copy(mesh.position);
                 body.material = new CANNON.Material({ friction: 0.4, restitution: 0.6 });
                 body.linearDamping = 0.4; // 添加阻尼
                 body.angularDamping = 0.4;
                 world.add(body);
                 bodies.push(body);
             }
             
             // 创建悬浮物体（15个）
             const floatingGeometries = [
                 new THREE.TorusKnotGeometry(0.6, 0.2, 64, 16, 3, 5),
                 new THREE.IcosahedronGeometry(0.8, 3),
                 new THREE.OctahedronGeometry(0.9, 3),
                 new THREE.DodecahedronGeometry(0.7, 2),
                 new THREE.TorusGeometry(0.8, 0.3, 32, 64),
                 new THREE.SphereGeometry(0.6, 64, 64),
                 new THREE.TetrahedronGeometry(1.0, 3),
                 new THREE.TorusKnotGeometry(0.5, 0.15, 64, 16, 4, 3),
                 new THREE.ConeGeometry(0.6, 1.2, 32),
                 new THREE.CylinderGeometry(0.4, 0.4, 1.0, 32),
                 new THREE.TorusKnotGeometry(0.7, 0.25, 64, 16, 2, 7),
                 new THREE.IcosahedronGeometry(0.6, 4),
                 new THREE.OctahedronGeometry(0.7, 4),
                 new THREE.TorusGeometry(0.6, 0.2, 32, 64),
                 new THREE.SphereGeometry(0.5, 64, 64)
             ];
             
             // 增加悬浮模型数量到35个，并重新分布位置
              for (let i = 0; i < 35; i++) {
                  const geometry = floatingGeometries[i % floatingGeometries.length];
                  const hue = (i / 35) * 360 + 180; // 不同的色调
                  const material = createBlenderMaterial(
                      new THREE.Color().setHSL(hue / 360, 0.7, 0.5),
                      0.8,
                      0.2
                  );
                  
                  const mesh = new THREE.Mesh(geometry, material);
                  
                  // 重新调整悬浮模型位置，在空中均匀分布
                   // 摄像头位置在(0, 5, 10)，所以模型需要在z < 10的位置
                   let x, y, z;
                   
                   // 使用球面坐标系统创建均匀分布
                   const phi = Math.acos(-1 + (2 * i) / 35); // 极角
                   const theta = Math.sqrt(35 * Math.PI) * phi; // 方位角
                   
                   // 转换为笛卡尔坐标，并调整到合适的范围
                   const radius = 8 + Math.random() * 4; // 半径 8-12
                   x = radius * Math.sin(phi) * Math.cos(theta);
                   y = 3 + radius * Math.sin(phi) * Math.sin(theta) * 0.5; // y轴压缩，保持在视野内
                   z = 2 + (radius * Math.cos(phi) + radius) * 0.25; // z轴控制在摄像头前方
                   
                   // 确保所有模型都在视野范围内
                   x = Math.max(-12, Math.min(12, x));
                   y = Math.max(1, Math.min(12, y));
                   z = Math.max(1, Math.min(8, z));
                   
                   // 根据距离中心的远近调整尺寸
                   const distanceFromCenter = Math.sqrt(x*x + (y-6)*(y-6) + (z-4)*(z-4));
                   const scaleMultiplier = 0.8 + (distanceFromCenter / 15) * 0.8; // 0.8-1.6倍
                   mesh.scale.setScalar(scaleMultiplier);
                  
                  mesh.position.set(x, y, z);
                  mesh.castShadow = true;
                  mesh.receiveShadow = true;
                  mesh.userData = { isFloating: true, isAnimating: false };
                  scene.add(mesh);
                  floatingObjects.push(mesh);
                  
                  // 记录原始位置
                  floatingOriginalPositions.push(mesh.position.clone());
                  
                  // 创建悬浮物理体（无重力影响）
                  const body = new CANNON.Body({ mass: 0 }); // 质量为0，不受重力影响
                  body.addShape(new CANNON.Sphere(0.5));
                  body.position.copy(mesh.position);
                  body.type = CANNON.Body.KINEMATIC; // 运动学物体，不受物理力影响
                  world.add(body);
                  floatingBodies.push(body);
              }
            
            // 动态高斯模糊背景
        const backgroundCanvas = document.createElement('canvas');
        backgroundCanvas.width = 512;
        backgroundCanvas.height = 512;
        const backgroundCtx = backgroundCanvas.getContext('2d');
            
            function updateBackground() {
                const time = Date.now() * 0.001;
                
                // 创建多层流动渐变
                const gradient1 = backgroundCtx.createRadialGradient(
                    256 + Math.sin(time * 0.3) * 150, 
                    256 + Math.cos(time * 0.2) * 150, 
                    0,
                    256, 256, 500
                );
                
                gradient1.addColorStop(0, `hsl(${240 + Math.sin(time * 0.15) * 30}, 80%, 18%)`);
                gradient1.addColorStop(0.2, `hsl(${260 + Math.cos(time * 0.12) * 25}, 70%, 14%)`);
                gradient1.addColorStop(0.5, `hsl(${280 + Math.sin(time * 0.08) * 20}, 60%, 10%)`);
                gradient1.addColorStop(0.8, `hsl(${220 + Math.cos(time * 0.18) * 35}, 85%, 6%)`);
                gradient1.addColorStop(1, `hsl(${200 + Math.sin(time * 0.25) * 40}, 90%, 3%)`);
                
                backgroundCtx.fillStyle = gradient1;
                backgroundCtx.fillRect(0, 0, 512, 512);
                
                // 添加第二层流动渐变
                backgroundCtx.globalCompositeOperation = 'overlay';
                const gradient2 = backgroundCtx.createLinearGradient(
                    Math.sin(time * 0.4) * 256, 0,
                    Math.cos(time * 0.4) * 256, 512
                );
                
                gradient2.addColorStop(0, `hsla(${300 + Math.sin(time * 0.1) * 20}, 60%, 8%, 0.3)`);
                gradient2.addColorStop(0.5, `hsla(${250 + Math.cos(time * 0.13) * 15}, 70%, 12%, 0.5)`);
                gradient2.addColorStop(1, `hsla(${320 + Math.sin(time * 0.17) * 25}, 50%, 5%, 0.2)`);
                
                backgroundCtx.fillStyle = gradient2;
                backgroundCtx.fillRect(0, 0, 512, 512);
                
                backgroundCtx.globalCompositeOperation = 'source-over';
                
                // 添加流动粒子效果
                backgroundCtx.globalCompositeOperation = 'screen';
                for (let i = 0; i < 20; i++) {
                    const x = (Math.sin(time * 0.1 + i) * 0.5 + 0.5) * 512;
                    const y = (Math.cos(time * 0.08 + i * 0.5) * 0.5 + 0.5) * 512;
                    const size = Math.sin(time * 0.2 + i) * 3 + 5;
                    
                    const particleGradient = backgroundCtx.createRadialGradient(x, y, 0, x, y, size);
                    particleGradient.addColorStop(0, `hsla(${240 + i * 10}, 80%, 40%, 0.1)`);
                    particleGradient.addColorStop(1, 'hsla(240, 80%, 40%, 0)');
                    
                    backgroundCtx.fillStyle = particleGradient;
                    backgroundCtx.beginPath();
                    backgroundCtx.arc(x, y, size, 0, Math.PI * 2);
                    backgroundCtx.fill();
                }
                
                backgroundCtx.globalCompositeOperation = 'source-over';
                backgroundTexture.needsUpdate = true;
            }
            
            const backgroundTexture = new THREE.CanvasTexture(backgroundCanvas);
            backgroundTexture.minFilter = THREE.LinearFilter;
            backgroundTexture.magFilter = THREE.LinearFilter;
            scene.background = backgroundTexture;
            
            // 定期更新背景和地面
            setInterval(() => {
                updateBackground();
                updateGroundWave();
            }, 50); // 更频繁的更新，更流畅的效果
            updateBackground();
            
            // 高级光照系统（调整为昏暗氛围）
            const ambientLight = new THREE.AmbientLight(0x2a2a3a, 0.2); // 进一步降低环境光
            scene.add(ambientLight);
            
            // 添加雾效果，增强深度感
            scene.fog = new THREE.Fog(0x1a1a2e, 10, 50);
            
            // 添加流动变化的地面平面
            const groundGeometry = new THREE.PlaneGeometry(50, 50, 128, 128);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a2e,
                metalness: 0.1,
                roughness: 0.9,
                transparent: true,
                opacity: 0.15, // 大幅降低透明度，几乎隐形
                fog: true,
                side: THREE.DoubleSide
            });
            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.position.y = -8;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);
            
            // 添加地面波动效果
            function updateGroundWave() {
                const time = Date.now() * 0.001;
                const positions = groundGeometry.attributes.position;
                
                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i);
                    const z = positions.getZ(i);
                    const wave = Math.sin(x * 0.1 + time) * Math.cos(z * 0.1 + time * 0.7) * 0.3;
                    positions.setY(i, wave);
                }
                
                positions.needsUpdate = true;
                groundGeometry.computeVertexNormals();
                
                // 动态调整地面颜色和透明度
                const opacity = 0.1 + Math.sin(time * 0.5) * 0.05; // 0.05-0.15之间变化
                const hue = (240 + Math.sin(time * 0.3) * 30) / 360; // 蓝紫色调变化
                groundMaterial.opacity = opacity;
                groundMaterial.color.setHSL(hue, 0.6, 0.1);
            }
            
            const directionalLight = new THREE.DirectionalLight(0x9a9aaa, 1.2);
            directionalLight.position.set(10, 15, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -25;
            directionalLight.shadow.camera.right = 25;
            directionalLight.shadow.camera.top = 25;
            directionalLight.shadow.camera.bottom = -25;
            scene.add(directionalLight);
            
            const pointLight1 = new THREE.PointLight(0x4a5c7a, 0.8, 25);
            pointLight1.position.set(-8, 8, 8);
            pointLight1.castShadow = true;
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x7a4a6b, 0.8, 25);
            pointLight2.position.set(8, 8, -8);
            pointLight2.castShadow = true;
            scene.add(pointLight2);
            
            const pointLight3 = new THREE.PointLight(0x5a7a4a, 0.6, 20);
            pointLight3.position.set(0, 12, 0);
            scene.add(pointLight3);
            
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);
            
            // 增强鼠标交互系统
             const raycaster = new THREE.Raycaster();
             const mouse = new THREE.Vector2();
             let selectedObject = null;
             let selectedBody = null;
             let isDragging = false;
             let hoveredObject = null;
             
             function onMouseMove(event) {
                 mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                 mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                 
                 // 检测悬停
                 raycaster.setFromCamera(mouse, camera);
                 const allObjects = [...objects, ...floatingObjects];
                 const intersects = raycaster.intersectObjects(allObjects);
                 
                 // 重置之前悬停的物体
                 if (hoveredObject && hoveredObject !== selectedObject) {
                     hoveredObject.userData.isHovered = false;
                 }
                 
                 // 设置新的悬停物体
                 if (intersects.length > 0 && !isDragging) {
                     hoveredObject = intersects[0].object;
                     hoveredObject.userData.isHovered = true;
                     canvas.style.cursor = 'pointer';
                 } else {
                     hoveredObject = null;
                     canvas.style.cursor = 'default';
                 }
                 
                 // 拖拽逻辑
                 if (isDragging && selectedBody) {
                     const intersectPoint = new THREE.Vector3();
                     raycaster.ray.intersectPlane(
                         new THREE.Plane(new THREE.Vector3(0, 0, 1), 0),
                         intersectPoint
                     );
                     
                     const force = new CANNON.Vec3(
                         (intersectPoint.x - selectedBody.position.x) * 25, // 降低力度
                         (intersectPoint.y - selectedBody.position.y) * 25,
                         0
                     );
                     selectedBody.applyForce(force, selectedBody.position);
                 }
             }
             
             function onMouseDown(event) {
                 mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                 mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                 
                 raycaster.setFromCamera(mouse, camera);
                 const allObjects = [...objects, ...floatingObjects];
                 const intersects = raycaster.intersectObjects(allObjects);
                 
                 if (intersects.length > 0) {
                     selectedObject = intersects[0].object;
                     const groundIndex = objects.indexOf(selectedObject);
                     const floatingIndex = floatingObjects.indexOf(selectedObject);
                     
                     if (groundIndex !== -1) {
                         // 地面物体点击效果
                         selectedBody = bodies[groundIndex];
                         isDragging = true;
                         
                         const throwForce = new CANNON.Vec3(
                             (Math.random() - 0.5) * 15,
                             Math.random() * 20 + 10,
                             (Math.random() - 0.5) * 15
                         );
                         selectedBody.applyImpulse(throwForce, selectedBody.position);
                     } else if (floatingIndex !== -1) {
                         // 悬浮物体点击效果：上下晃动
                         const floatingMesh = floatingObjects[floatingIndex];
                         const originalPos = floatingOriginalPositions[floatingIndex];
                         
                         floatingMesh.userData.isAnimating = true;
                         
                         // 创建晃动动画
                         const startTime = Date.now();
                         const animateBounce = () => {
                             const elapsed = (Date.now() - startTime) / 1000;
                             const duration = 2.0; // 动画持续2秒
                             
                             if (elapsed < duration) {
                                 const progress = elapsed / duration;
                                 const bounce = Math.sin(progress * Math.PI * 4) * Math.exp(-progress * 3);
                                 floatingMesh.position.y = originalPos.y + bounce * 3;
                                 floatingBodies[floatingIndex].position.y = floatingMesh.position.y;
                                 requestAnimationFrame(animateBounce);
                             } else {
                                 // 归位
                                 floatingMesh.position.copy(originalPos);
                                 floatingBodies[floatingIndex].position.copy(originalPos);
                                 floatingMesh.userData.isAnimating = false;
                             }
                         };
                         animateBounce();
                     }
                 }
             }
             
             function onMouseUp() {
                 selectedObject = null;
                 selectedBody = null;
                 isDragging = false;
             }
             
             canvas.addEventListener('mousemove', onMouseMove);
             canvas.addEventListener('mousedown', onMouseDown);
             canvas.addEventListener('mouseup', onMouseUp);
            
            // 添加温和的随机力和悬浮效果
             function addRandomForces() {
                 bodies.forEach((body, index) => {
                     // 降低随机力频率和强度
                     if (Math.random() < 0.005) {
                         const force = new CANNON.Vec3(
                             (Math.random() - 0.5) * 8,
                             Math.random() * 5,
                             (Math.random() - 0.5) * 8
                         );
                         body.applyForce(force, body.position);
                     }
                 });
             }
             
             // 悬浮效果
             function updateFloatingEffect() {
                 objects.forEach((obj, index) => {
                     if (obj.userData.isHovered && !isDragging) {
                         const time = Date.now() * 0.003;
                         const floatOffset = Math.sin(time + index) * 0.3;
                         const targetY = obj.userData.originalY + 1.5 + floatOffset;
                         
                         // 温和的悬浮力
                         const currentY = bodies[index].position.y;
                         const floatForce = (targetY - currentY) * 8;
                         bodies[index].applyForce(new CANNON.Vec3(0, floatForce, 0), bodies[index].position);
                     }
                 });
             }
            
            // 动画循环
            function animate() {
                requestAnimationFrame(animate);
                
                // 更新物理世界
                world.step(1/60);
                
                // 同步地面物体
                for (let i = 0; i < objects.length; i++) {
                    objects[i].position.copy(bodies[i].position);
                    objects[i].quaternion.copy(bodies[i].quaternion);
                    
                    // 动态颜色变化（更柔和的色彩）
                    const time = Date.now() * 0.001;
                    const hue = ((time * 0.05 + i * 0.067) % 1);
                    objects[i].material.color.setHSL(hue, 0.7, 0.5);
                    
                    // 边界检查，防止物体掉落太远
                 if (bodies[i].position.y < -12) {
                     bodies[i].position.set(
                         (Math.random() - 0.5) * 10,
                         Math.random() * 6 + 8,
                         (Math.random() - 0.5) * 10
                     );
                     bodies[i].velocity.set(0, 0, 0);
                     bodies[i].angularVelocity.set(0, 0, 0);
                     objects[i].userData.originalY = bodies[i].position.y;
                 }
                }
                
                // 悬浮物体的缓慢旋转和浮动
                 const floatingTime = Date.now() * 0.001;
                 for (let i = 0; i < floatingObjects.length; i++) {
                     const mesh = floatingObjects[i];
                     const originalPos = floatingOriginalPositions[i];
                     
                     // 缓慢旋转
                     mesh.rotation.x += 0.005;
                     mesh.rotation.y += 0.003;
                     mesh.rotation.z += 0.002;
                     
                     // 轻微浮动（如果没有在执行点击动画）
                     if (!mesh.userData.isAnimating) {
                         const floatOffset = Math.sin(floatingTime * 0.5 + i) * 0.5;
                         mesh.position.y = originalPos.y + floatOffset;
                         floatingBodies[i].position.copy(mesh.position);
                     }
                     
                     // 悬浮物体颜色变化
                     const hue = (i / floatingObjects.length + floatingTime * 0.03 + 0.5) % 1;
                     mesh.material.color.setHSL(hue, 0.7, 0.5);
                 }
                
                // 添加随机力和悬浮效果
                 addRandomForces();
                 updateFloatingEffect();
                
                // 相机轻微摆动
                const time = Date.now() * 0.001;
                camera.position.x = Math.sin(time * 0.5) * 2;
                camera.position.y = 5 + Math.sin(time * 0.3) * 1;
                camera.lookAt(0, 0, 0);
                
                renderer.render(scene, camera);
            }
            
            animate();
            
            // 响应式处理
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        // 滚动动画初始化
        function initScrollAnimations() {
            // Hero标题动画
            gsap.fromTo('.hero-title', 
                { y: 100, opacity: 0 },
                { y: 0, opacity: 1, duration: 1.5, ease: 'power3.out' }
            );
            
            gsap.fromTo('.hero-subtitle', 
                { y: 50, opacity: 0 },
                { y: 0, opacity: 1, duration: 1.5, delay: 0.3, ease: 'power3.out' }
            );
            
            // 为后续内容预留动画空间
            
            // 液态文字交互演示初始化
            initLiquidTextEffect();
        }
        
        // 液态文字交互效果
        function initLiquidTextEffect() {
            const canvas = document.getElementById('liquid-canvas');
            const textElement = document.getElementById('liquidText');
            const bgCanvas = document.getElementById('liquidBgCanvas');
            
            if (!canvas || !textElement || !bgCanvas) return;
            
            // 初始化动态高斯模糊背景
            initLiquidBackground(bgCanvas);
            
            function initLiquidBackground(bgCanvas) {
                const ctx = bgCanvas.getContext('2d');
                
                function resizeBgCanvas() {
                    bgCanvas.width = window.innerWidth;
                    bgCanvas.height = window.innerHeight;
                }
                resizeBgCanvas();
                
                function animateBackground() {
                    const time = Date.now() * 0.0015; // 加快动画速度
                    
                    // 清除画布
                    ctx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
                    
                    // 设置混合模式
                    ctx.globalCompositeOperation = 'source-over';
                    
                    // 基础色调 #180525
                    const baseHue = 285; // #180525 对应的色相
                    
                    // 创建多层动态渐变
                    for (let i = 0; i < 8; i++) {
                        const hueShift = Math.sin(time + i * 0.5) * 60; // 增大色相变化范围
                        const saturation = 70 + Math.sin(time * 0.4 + i) * 30; // 增强饱和度变化
                        const lightness = 20 + Math.sin(time * 0.3 + i * 0.3) * 15; // 增强亮度变化
                        
                        const x = (Math.sin(time * 0.1 + i) * 0.3 + 0.5) * bgCanvas.width;
                        const y = (Math.cos(time * 0.08 + i * 0.7) * 0.3 + 0.5) * bgCanvas.height;
                        const radius = (Math.sin(time * 0.15 + i * 0.4) * 0.2 + 0.4) * Math.min(bgCanvas.width, bgCanvas.height);
                        
                        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                        gradient.addColorStop(0, `hsla(${baseHue + hueShift}, ${saturation}%, ${lightness + 10}%, 0.6)`);
                        gradient.addColorStop(0.5, `hsla(${baseHue + hueShift * 0.7}, ${saturation * 0.8}%, ${lightness * 0.7 + 8}%, 0.3)`);
                        gradient.addColorStop(1, 'hsla(285, 60%, 15%, 0)');
                        
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
                    }
                    
                    // 添加流动粒子
                    for (let i = 0; i < 15; i++) {
                        const particleTime = time + i * 0.4;
                        const x = (Math.sin(particleTime * 0.18) * 0.5 + 0.5) * bgCanvas.width; // 加快运动速度
                        const y = (Math.cos(particleTime * 0.14) * 0.5 + 0.5) * bgCanvas.height; // 加快运动速度
                        const size = (Math.sin(particleTime * 0.3) * 0.6 + 0.6) * 100; // 增大粒子尺寸
                        
                        const hue = baseHue + Math.sin(particleTime) * 80; // 增大色相变化范围
                        const particleSat = 80 + Math.sin(particleTime * 0.5) * 20; // 动态饱和度
                        const particleLight = 40 + Math.sin(particleTime * 0.7) * 20; // 动态亮度
                        const particleGradient = ctx.createRadialGradient(x, y, 0, x, y, size);
                        particleGradient.addColorStop(0, `hsla(${hue}, ${particleSat}%, ${particleLight}%, 0.5)`);
                        particleGradient.addColorStop(1, 'hsla(285, 70%, 25%, 0)');
                        
                        ctx.fillStyle = particleGradient;
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    requestAnimationFrame(animateBackground);
                }
                
                animateBackground();
                
                window.addEventListener('resize', resizeBgCanvas);
            }
            
            // Three.js 场景设置
            const scene = new THREE.Scene();
            const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            const renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                alpha: true,
                antialias: true
            });
            
            // 响应式设置
            function updateSize() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                renderer.setSize(width, height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            }
            updateSize();
            
            // 创建文字纹理
            function createTextTexture() {
                const textCanvas = document.createElement('canvas');
                const ctx = textCanvas.getContext('2d');
                
                // 高分辨率设置
                const scale = 2;
                textCanvas.width = 2048 * scale;
                textCanvas.height = 1024 * scale;
                ctx.scale(scale, scale);
                
                // 文字样式
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 120px Technonomicon, monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // 绘制文字
                const lines = ['DISSOLVE', 'YOURSELF'];
                lines.forEach((line, index) => {
                    ctx.fillText(line, textCanvas.width / (2 * scale), 
                        (textCanvas.height / (2 * scale)) + (index - 0.5) * 150);
                });
                
                return new THREE.CanvasTexture(textCanvas);
            }
            
            // 着色器材质
            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;
            
            const fragmentShader = `
                uniform float uTime;
                uniform vec2 uMouse;
                uniform sampler2D uTexture;
                uniform float uDissolveRadius;
                uniform float uDissolveStrength;
                varying vec2 vUv;
                
                // 噪声函数
                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }
                
                float noise(vec2 st) {
                    vec2 i = floor(st);
                    vec2 f = fract(st);
                    float a = random(i);
                    float b = random(i + vec2(1.0, 0.0));
                    float c = random(i + vec2(0.0, 1.0));
                    float d = random(i + vec2(1.0, 1.0));
                    vec2 u = f * f * (3.0 - 2.0 * f);
                    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
                }
                
                void main() {
                    vec2 uv = vUv;
                    
                    // 鼠标距离计算
                    float mouseDistance = distance(uv, uMouse);
                    float dissolveEffect = smoothstep(uDissolveRadius, 0.0, mouseDistance);
                    
                    // 噪声驱动的溶解效果
                    float noiseValue = noise(uv * 8.0 + uTime * 0.5);
                    float dissolve = dissolveEffect * uDissolveStrength;
                    
                    // UV扭曲
                    vec2 distortion = vec2(
                        sin(uTime * 2.0 + uv.y * 10.0) * dissolve * 0.1,
                        cos(uTime * 1.5 + uv.x * 8.0) * dissolve * 0.1
                    );
                    
                    vec2 distortedUV = uv + distortion;
                    
                    // 采样纹理
                    vec4 textColor = texture2D(uTexture, distortedUV);
                    
                    // 溶解边缘效果
                    float alpha = textColor.a;
                    alpha *= (1.0 - dissolve * (noiseValue * 0.8 + 0.2));
                    
                    // 颜色变化
                    vec3 color = textColor.rgb;
                    color = mix(color, vec3(0.2, 0.8, 1.0), dissolve * 0.3);
                    
                    gl_FragColor = vec4(color, alpha);
                }
            `;
            
            // 创建材质和几何体
            const textTexture = createTextTexture();
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uMouse: { value: new THREE.Vector2(0.5, 0.5) },
                    uTexture: { value: textTexture },
                    uDissolveRadius: { value: 0.15 },
                    uDissolveStrength: { value: 1.0 }
                },
                vertexShader,
                fragmentShader,
                transparent: true
            });
            
            const geometry = new THREE.PlaneGeometry(2, 2);
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            
            // 鼠标交互
            const mouse = new THREE.Vector2();
            let isMouseOver = false;
            
            function onMouseMove(event) {
                mouse.x = event.clientX / window.innerWidth;
                mouse.y = 1.0 - (event.clientY / window.innerHeight);
                material.uniforms.uMouse.value.set(mouse.x, mouse.y);
                isMouseOver = true;
            }
            
            function onMouseLeave() {
                isMouseOver = false;
            }
            
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseleave', onMouseLeave);
            
            // 动画循环
            function animate() {
                requestAnimationFrame(animate);
                
                const time = performance.now() * 0.001;
                material.uniforms.uTime.value = time;
                
                // 平滑的溶解强度过渡
                const targetStrength = isMouseOver ? 1.0 : 0.0;
                material.uniforms.uDissolveStrength.value += 
                    (targetStrength - material.uniforms.uDissolveStrength.value) * 0.05;
                
                renderer.render(scene, camera);
            }
            
            animate();
            
            // 显示文字元素作为备用
            setTimeout(() => {
                textElement.style.opacity = '0.1';
            }, 100);
            
            // 窗口大小变化处理
            window.addEventListener('resize', updateSize);
        }
    </script>
</body>
</html>