<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web 技术炫技展示 | 最前沿的网页特效</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 25%, #0f3460 50%, #533483 75%, #7209b7 100%);
            color: #fff;
            overflow-x: hidden;
        }

        /* Hero 区域 */
        .hero {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .hero-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .hero-content {
            position: relative;
            z-index: 10;
            text-align: center;
            pointer-events: none;
        }

        .hero-title {
            font-family: 'Technonomicon', Arial, sans-serif;
            font-size: clamp(2rem, 5.33vw, 5.33rem);
            font-weight: 900;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffeaa7);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
            margin-bottom: 1rem;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
        }

        .hero-subtitle {
            font-size: clamp(1.2rem, 3vw, 2rem);
            opacity: 0.8;
            margin-bottom: 2rem;
            letter-spacing: 2px;
        }

        @font-face {
            font-family: 'Pixely';
            src: url('./fonts/pixely.ttf') format('truetype');
            font-display: swap;
        }

        @font-face {
            font-family: 'Technonomicon';
            src: url('./fonts/Technonomicon.ttf') format('truetype');
            font-display: swap;
        }

        .terminal-text {
            font-family: 'Pixely', 'Courier New', 'Monaco', 'Menlo', monospace;
            color: #00ff00 !important;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 5px;
            text-shadow: 0 0 10px #00ff00;
            letter-spacing: 1px;
            font-weight: bold;
            border: 1px solid #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            animation: textFlicker 2s infinite;
        }

        .cursor {
            animation: blink 0.8s infinite;
            color: #00ff00;
            background-color: #00ff00;
            display: inline-block;
            width: 12px;
            height: 0.8em;
            margin-left: 2px;
            vertical-align: baseline;
        }

        .signature {
            position: absolute;
            top: 20px;
            right: 20px;
            font-family: 'Pixely', monospace;
            font-size: 14px;
            color: #00ff00;
            text-decoration: none;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 3px;
            text-shadow: 0 0 10px #00ff00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
            animation: signatureFlicker 0.3s infinite;
            transition: all 0.2s ease;
            z-index: 1000;
        }

        .signature:hover {
            background-color: rgba(0, 255, 0, 0.1);
            box-shadow: 0 0 25px rgba(0, 255, 0, 0.5);
            transform: scale(1.05);
        }

        @keyframes signatureFlicker {
            0%, 100% {
                opacity: 1;
                text-shadow: 0 0 10px #00ff00;
            }
            25% {
                opacity: 0.8;
                text-shadow: 0 0 5px #00ff00;
            }
            50% {
                opacity: 0.9;
                text-shadow: 0 0 15px #00ff00;
            }
            75% {
                opacity: 0.7;
                text-shadow: 0 0 8px #00ff00;
            }
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        @keyframes textFlicker {
            0%, 98% { 
                opacity: 1;
                text-shadow: 0 0 10px #00ff00;
            }
            99% { 
                opacity: 0.95;
                text-shadow: 0 0 8px #00ff00;
            }
            100% { 
                opacity: 0.98;
                text-shadow: 0 0 12px #00ff00;
            }
        }

        /* 内容流区域 */
        .content-flow {
            position: relative;
            z-index: 5;
            min-height: 100vh;
        }

        /* 液态文字交互演示 */
        .liquid-text-section {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            background: #180525;
        }

        .liquid-bg-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            filter: blur(25px);
            opacity: 0.9;
        }

        #liquid-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        .liquid-text-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1;
            pointer-events: none;
        }

        .liquid-text {
            font-family: 'Technonomicon', monospace;
            font-size: clamp(4rem, 12vw, 12rem);
            font-weight: bold;
            color: #ffffff;
            text-align: center;
            line-height: 1.2;
            letter-spacing: 0.1em;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* 动画 */
        @keyframes gradientShift {
            0%, 100% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateX(-50%) translateY(0);
            }
            40% {
                transform: translateX(-50%) translateY(-10px);
            }
            60% {
                transform: translateX(-50%) translateY(-5px);
            }
        }

        @keyframes colorShift {
            0%, 100% {
                transform: translate(0, 0) rotate(0deg);
                filter: hue-rotate(0deg) saturate(1) brightness(1);
            }
            20% {
                transform: translate(-3%, 2%) rotate(0.5deg);
                filter: hue-rotate(15deg) saturate(1.1) brightness(1.05);
            }
            40% {
                transform: translate(2%, -2%) rotate(-0.3deg);
                filter: hue-rotate(30deg) saturate(1.2) brightness(0.95);
            }
            60% {
                transform: translate(-1%, 3%) rotate(0.2deg);
                filter: hue-rotate(45deg) saturate(1.15) brightness(1.1);
            }
            80% {
                transform: translate(3%, -1%) rotate(-0.4deg);
                filter: hue-rotate(60deg) saturate(1.05) brightness(0.9);
            }
        }

        /* 滚动交互展示区样式 */
        .scroll-interaction-section {
            position: relative;
            background: linear-gradient(180deg, #001100 0%, #002200 50%, #003300 100%);
            min-height: 500vh; /* 足够长的滚动区域 */
            overflow: hidden;
            font-family: 'Pixely', monospace;
            /* 复古终端扫描线效果 */
            background-image: 
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 2px,
                    rgba(0, 255, 0, 0.03) 2px,
                    rgba(0, 255, 0, 0.03) 4px
                );
            /* 终端闪烁效果 */
            animation: terminalFlicker 0.15s infinite linear alternate;
        }
        
        @keyframes terminalFlicker {
            0% { opacity: 1; }
            98% { opacity: 1; }
            99% { opacity: 0.98; }
            100% { opacity: 1; }
        }
        
        .scroll-container {
            position: relative;
            width: 100%;
            height: 100%;
            padding: 100px 50px;
        }
        
        /* 标题区域 */
        .scroll-title-area {
            text-align: center;
            margin-bottom: 200px;
            opacity: 0;
            transform: translateY(100px);
        }
        
        .scroll-main-title {
            font-family: 'Pixely', monospace;
            font-size: clamp(3rem, 8vw, 8rem);
            font-weight: 900;
            color: #00ff00;
            text-shadow: 
                0 0 5px #00ff00,
                0 0 10px #00ff00,
                0 0 15px #00ff00,
                0 0 20px #00ff00;
            margin-bottom: 20px;
            letter-spacing: 0.2em;
            animation: terminalGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes terminalGlow {
            0% { 
                text-shadow: 
                    0 0 5px #00ff00,
                    0 0 10px #00ff00,
                    0 0 15px #00ff00,
                    0 0 20px #00ff00;
            }
            100% { 
                text-shadow: 
                    0 0 10px #00ff00,
                    0 0 20px #00ff00,
                    0 0 30px #00ff00,
                    0 0 40px #00ff00;
            }
        }
        
        .scroll-subtitle {
            font-family: 'Pixely', monospace;
            font-size: clamp(1.2rem, 3vw, 2rem);
            color: #00cc00;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            text-shadow: 0 0 10px #00cc00;
        }
        
        /* 终端元素容器 */
        .terminal-elements-container {
            position: relative;
            width: 100%;
            height: 300vh;
            margin: 200px 0;
        }
        
        .terminal-element {
            position: absolute;
            opacity: 0;
            transform: scale(0.8);
            background: rgba(0, 20, 0, 0.8);
            border: 1px solid #00ff00;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 
                0 0 20px rgba(0, 255, 0, 0.3),
                inset 0 0 20px rgba(0, 255, 0, 0.1);
            backdrop-filter: blur(5px);
        }
        
        /* 大小类 */
        .terminal-element.size-small {
            font-size: 0.7em;
            padding: 8px;
            transform: scale(0.6);
        }
        
        .terminal-element.size-medium {
            font-size: 0.9em;
            padding: 15px;
            transform: scale(0.8);
        }
        
        .terminal-element.size-large {
            font-size: 1.2em;
            padding: 20px;
            transform: scale(1.0);
        }
        
        /* ASCII艺术元素 */
        .ascii-art-1 {
            top: 10%;
            left: 10%;
            z-index: 3;
        }
        
        .ascii-art-2 {
            top: 25%;
            right: 15%;
            z-index: 3;
        }
        
        .ascii-art-3 {
            top: 5%;
            left: 60%;
            z-index: 4;
        }
        
        .ascii-art-4 {
            top: 40%;
            left: 5%;
            z-index: 2;
        }
        
        .ascii-art-5 {
            top: 55%;
            right: 5%;
            z-index: 3;
        }
        
        .ascii-art-6 {
            top: 70%;
            left: 30%;
            z-index: 1;
        }
        
        .ascii-art-7 {
            top: 15%;
            left: 35%;
            z-index: 5;
        }
        
        .ascii-text {
            font-family: 'Pixely', monospace;
            font-size: 1.2rem;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
            line-height: 1.2;
            margin: 0;
            white-space: pre;
        }
        
        /* 代码块元素 */
        .code-block-1 {
            top: 45%;
            left: 5%;
            z-index: 2;
        }
        
        .code-block-2 {
            top: 20%;
            right: 25%;
            z-index: 3;
        }
        
        .code-block-3 {
            top: 65%;
            left: 70%;
            z-index: 1;
        }
        
        .code-block-4 {
            top: 80%;
            left: 15%;
            z-index: 2;
        }
        
        .code-block-5 {
            top: 35%;
            right: 40%;
            z-index: 1;
        }
        
        .code-text {
            font-family: 'Pixely', monospace;
            font-size: 1rem;
            color: #00cc00;
            text-shadow: 0 0 8px #00cc00;
            line-height: 1.4;
            margin: 0;
            white-space: pre;
        }
        
        /* 矩阵雨效果 */
        .matrix-rain {
            top: 15%;
            left: 50%;
            z-index: 4;
            background: rgba(0, 0, 0, 0.9);
        }
        
        .matrix-rain-2 {
            top: 50%;
            left: 25%;
            z-index: 2;
            background: rgba(0, 0, 0, 0.9);
        }
        
        .matrix-rain-3 {
            top: 75%;
            right: 30%;
            z-index: 3;
            background: rgba(0, 0, 0, 0.9);
        }
        
        .matrix-rain-4 {
            top: 30%;
            left: 80%;
            z-index: 1;
            background: rgba(0, 0, 0, 0.9);
        }
        
        .matrix-column {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .matrix-column span {
            font-family: 'Pixely', monospace;
            font-size: 1.5rem;
            color: #00ff00;
            text-shadow: 0 0 15px #00ff00;
            animation: matrixFall 2s infinite linear;
        }
        
        .matrix-column span:nth-child(2) { animation-delay: 0.5s; }
        .matrix-column span:nth-child(3) { animation-delay: 1s; }
        .matrix-column span:nth-child(4) { animation-delay: 1.5s; }
        
        @keyframes matrixFall {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0.3; transform: translateY(20px); }
        }
        
        /* 终端提示符 */
        .terminal-prompt {
            top: 60%;
            right: 10%;
            z-index: 2;
            min-width: 300px;
        }
        
        .terminal-prompt-2 {
            top: 85%;
            left: 45%;
            z-index: 3;
            min-width: 200px;
        }
        
        .terminal-prompt-3 {
            top: 25%;
            left: 15%;
            z-index: 1;
            min-width: 250px;
        }
        
        .terminal-prompt-4 {
            top: 90%;
            right: 35%;
            z-index: 2;
            min-width: 180px;
        }
        
        .prompt-text {
            font-family: 'Pixely', monospace;
            font-size: 0.9rem;
            color: #00dd00;
            text-shadow: 0 0 8px #00dd00;
            line-height: 1.3;
            margin: 0;
            white-space: pre;
        }
        
        /* 电路图案 */
        .circuit-pattern {
            top: 35%;
            right: 30%;
            z-index: 1;
            width: 120px;
            height: 120px;
            background: transparent;
            border: none;
            box-shadow: none;
        }
        
        .circuit-pattern-2 {
            top: 10%;
            left: 85%;
            z-index: 2;
            width: 80px;
            height: 80px;
            background: transparent;
            border: none;
            box-shadow: none;
        }
        
        .circuit-pattern-3 {
            top: 50%;
            right: 5%;
            z-index: 4;
            width: 150px;
            height: 150px;
            background: transparent;
            border: none;
            box-shadow: none;
        }
        
        .circuit-pattern-4 {
            top: 95%;
            left: 5%;
            z-index: 1;
            width: 60px;
            height: 60px;
            background: transparent;
            border: none;
            box-shadow: none;
        }
        
        .circuit-lines {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        .line {
            position: absolute;
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }
        
        .line.horizontal {
            width: 80px;
            height: 2px;
            top: 50%;
            left: 20px;
        }
        
        .line.vertical {
            width: 2px;
            height: 60px;
            left: 50%;
            top: 30px;
        }
        
        .node {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #00ff00;
            border-radius: 50%;
            box-shadow: 0 0 15px #00ff00;
            animation: nodePulse 2s infinite;
        }
        
        .node:first-of-type {
            top: 46px;
            left: 56px;
        }
        
        .node.node-2 {
            top: 46px;
            left: 96px;
            animation-delay: 1s;
        }
        
        @keyframes nodePulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.5); }
        }
        
        /* 进度条 */
        .progress-bars {
            top: 75%;
            left: 25%;
            z-index: 2;
            min-width: 200px;
        }
        
        .progress-bars-2 {
            top: 40%;
            right: 15%;
            z-index: 1;
            min-width: 150px;
        }
        
        .progress-bars-3 {
            top: 5%;
            left: 25%;
            z-index: 3;
            min-width: 250px;
        }
        
        .progress-bars-4 {
            top: 65%;
            right: 45%;
            z-index: 2;
            min-width: 120px;
        }
        
        .progress-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .progress-label {
            font-family: 'Pixely', monospace;
            font-size: 0.9rem;
            color: #00cc00;
            text-shadow: 0 0 8px #00cc00;
        }
        
        .progress-bar {
            width: 150px;
            height: 8px;
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #00ff00;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00cc00);
            box-shadow: 0 0 10px #00ff00;
            animation: progressPulse 3s infinite;
        }
        
        .progress-fill.cpu {
            width: 75%;
        }
        
        .progress-fill.ram {
            width: 60%;
            animation-delay: 1.5s;
        }
        
        @keyframes progressPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* 十六进制显示 */
        .hex-display {
            top: 85%;
            right: 20%;
            z-index: 3;
        }
        
        .hex-display-2 {
            top: 30%;
            left: 5%;
            z-index: 1;
        }
        
        .hex-display-3 {
            top: 45%;
            left: 40%;
            z-index: 4;
        }
        
        .hex-display-4 {
            top: 95%;
            right: 10%;
            z-index: 2;
        }
        
        .hex-text {
            font-family: 'Pixely', monospace;
            font-size: 1rem;
            color: #00aa00;
            text-shadow: 0 0 8px #00aa00;
            line-height: 1.3;
            margin: 0;
            white-space: pre;
        }
        
        /* 系统信息显示 */
        .system-info {
            top: 20%;
            right: 50%;
            z-index: 2;
        }
        
        .system-info-2 {
            top: 70%;
            left: 80%;
            z-index: 1;
        }
        
        .system-info-3 {
            top: 35%;
            left: 65%;
            z-index: 3;
        }
        
        .system-text {
            font-family: 'Pixely', monospace;
            font-size: 0.9rem;
            color: #00dd00;
            text-shadow: 0 0 8px #00dd00;
            line-height: 1.3;
            margin: 0;
            white-space: pre;
        }
        
        /* 网络状态显示 */
        .network-status {
            top: 55%;
            left: 55%;
            z-index: 4;
        }
        
        .network-status-2 {
            top: 15%;
            right: 5%;
            z-index: 2;
        }
        
        .network-text {
            font-family: 'Pixely', monospace;
            font-size: 0.8rem;
            color: #00bb00;
            text-shadow: 0 0 8px #00bb00;
            line-height: 1.4;
            margin: 0;
            white-space: pre;
        }
        
        /* 日志显示 */
        .log-display {
            top: 80%;
            left: 60%;
            z-index: 3;
        }
        
        .log-display-2 {
            top: 90%;
            left: 75%;
            z-index: 1;
        }
        
        .log-text {
            font-family: 'Pixely', monospace;
            font-size: 0.8rem;
            color: #00cc00;
            text-shadow: 0 0 8px #00cc00;
            line-height: 1.3;
            margin: 0;
            white-space: pre;
        }
        
        /* 文字动画区域 */
        .text-animation-area {
            margin: 400px 0;
            padding: 0 100px;
        }
        
        .animated-text-block {
            margin: 300px 0;
            text-align: center;
            opacity: 0;
            transform: translateX(-100px);
        }
        
        .block-title {
            font-family: 'Pixely', monospace;
            font-size: clamp(2.5rem, 6vw, 6rem);
            font-weight: 900;
            margin-bottom: 20px;
            color: #00ff00;
            text-shadow: 
                0 0 5px #00ff00,
                0 0 10px #00ff00,
                0 0 15px #00ff00;
            letter-spacing: 0.2em;
            animation: terminalPulse 3s ease-in-out infinite;
        }
        
        @keyframes terminalPulse {
            0%, 100% { 
                opacity: 1;
                text-shadow: 
                    0 0 5px #00ff00,
                    0 0 10px #00ff00,
                    0 0 15px #00ff00;
            }
            50% { 
                opacity: 0.8;
                text-shadow: 
                    0 0 10px #00ff00,
                    0 0 20px #00ff00,
                    0 0 30px #00ff00;
            }
        }
        
        .block-description {
            font-family: 'Pixely', monospace;
            font-size: clamp(1rem, 2vw, 1.5rem);
            color: #00cc00;
            letter-spacing: 0.15em;
            max-width: 600px;
            margin: 0 auto;
            text-shadow: 0 0 5px #00cc00;
        }
        
        /* 粒子系统 */
        .particle-system {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        
        #particleCanvas {
            width: 100%;
            height: 100%;
            filter: 
                hue-rotate(120deg)
                brightness(1.3)
                contrast(1.2)
                drop-shadow(0 0 10px rgba(0, 255, 0, 0.3));
            z-index: 1;
        }
        

        

        
        /* 动画关键帧 */
        @keyframes morphPulse {
            0%, 100% {
                transform: scale(1) rotate(0deg);
            }
            25% {
                transform: scale(1.2) rotate(90deg);
            }
            50% {
                transform: scale(0.8) rotate(180deg);
            }
            75% {
                transform: scale(1.1) rotate(270deg);
            }
        }
        
        @keyframes floatUpDown {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-20px);
            }
        }
        
        @keyframes rotateScale {
            0% {
                transform: rotate(0deg) scale(1);
            }
            50% {
                transform: rotate(180deg) scale(1.2);
            }
            100% {
                transform: rotate(360deg) scale(1);
            }
        }
        
        /* 响应式设计 */
        @media (max-width: 768px) {
            .hero-title {
                font-size: 3rem;
            }
            
            .hero-subtitle {
                font-size: 1.2rem;
            }
            
            .section {
                padding: 60px 15px;
            }
            
            .scroll-container {
                padding: 50px 20px;
            }
            
            .graphics-showcase {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 50px;
                margin: 200px 0;
                padding: 0 20px;
            }
            
            .graphic-element {
                width: 150px;
                height: 150px;
            }
            
            .text-animation-area {
                padding: 0 20px;
                margin: 200px 0;
            }
            
            .animated-text-block {
                margin: 150px 0;
            }
            

        }
    </style>
</head>
<body>
    <!-- Hero 区域 -->
    <section class="hero" id="hero">
        <canvas class="hero-canvas" id="heroCanvas"></canvas>
        <a href="https://open.spotify.com/track/3DK6m7It6Pw857FcQftMds?si=2577d4c1e3304221" target="_blank" class="signature">Kanye East</a>
        <div class="hero-content">
            <h1 class="hero-title">TUTORIALS</h1>
            <p class="hero-subtitle terminal-text" id="terminalSubtitle">VIBING CODING<span class="cursor">_</span></p>
        </div>

    </section>

    <!-- 后续内容区域 -->
    <main class="content-flow">
        <!-- 液态文字交互演示 -->
        <section class="liquid-text-section">
            <canvas class="liquid-bg-canvas" id="liquidBgCanvas"></canvas>
            <canvas id="liquid-canvas"></canvas>
            <div class="liquid-text-container">
                <div class="liquid-text" id="liquidText">DISSOLVE YOURSELF</div>
            </div>
        </section>
        
        <!-- 滚动交互展示区 -->
        <section class="scroll-interaction-section">
            <div class="scroll-container">
                <!-- 标题区域 -->
                <div class="scroll-title-area">
                    <h2 class="scroll-main-title">SCROLL DYNAMICS</h2>
                    <p class="scroll-subtitle">Experience the power of motion</p>
                </div>
                
                <!-- 分散的终端美学元素 -->
                <div class="terminal-elements-container">
                    <!-- ASCII艺术元素 -->
                    <div class="terminal-element ascii-art-1 size-medium">
                        <pre class="ascii-text">
 ╔══════════════╗
 ║   SYSTEM     ║
 ║   ONLINE     ║
 ╚══════════════╝
                        </pre>
                    </div>
                    
                    <div class="terminal-element ascii-art-2 size-small">
                        <pre class="ascii-text">
    ▲▲▲▲▲▲▲▲
   ▲ LOADING ▲
  ▲▲▲▲▲▲▲▲▲▲
                        </pre>
                    </div>
                    
                    <div class="terminal-element ascii-art-3 size-large">
                        <pre class="ascii-text">
████████╗███████╗██████╗ ███╗   ███╗
╚══██╔══╝██╔════╝██╔══██╗████╗ ████║
   ██║   █████╗  ██████╔╝██╔████╔██║
   ██║   ██╔══╝  ██╔══██╗██║╚██╔╝██║
   ██║   ███████╗██║  ██║██║ ╚═╝ ██║
   ╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝     ╚═╝
                        </pre>
                    </div>
                    
                    <div class="terminal-element ascii-art-4 size-small">
                        <pre class="ascii-text">
  [###    ]
  Loading...
                        </pre>
                    </div>
                    
                    <div class="terminal-element ascii-art-5 size-medium">
                        <pre class="ascii-text">
    ┌─────────┐
    │ SUCCESS │
    └─────────┘
       ✓ OK
                        </pre>
                    </div>
                    
                    <div class="terminal-element ascii-art-6 size-small">
                        <pre class="ascii-text">
  ░░░▒▒▒▓▓▓
  ▓▓▓▒▒▒░░░
                        </pre>
                    </div>
                    
                    <div class="terminal-element ascii-art-7 size-large">
                        <pre class="ascii-text">
 ██████╗ ██████╗ ██████╗ ███████╗
██╔════╝██╔═══██╗██╔══██╗██╔════╝
██║     ██║   ██║██║  ██║█████╗  
██║     ██║   ██║██║  ██║██╔══╝  
╚██████╗╚██████╔╝██████╔╝███████╗
 ╚═════╝ ╚═════╝ ╚═════╝ ╚══════╝
                        </pre>
                    </div>
                    
                    <!-- 代码块元素 -->
                    <div class="terminal-element code-block-1 size-medium">
                        <pre class="code-text">
> run_animation.exe
[████████████] 100%
STATUS: ACTIVE
> _
                        </pre>
                    </div>
                    
                    <div class="terminal-element code-block-2 size-large">
                        <pre class="code-text">
#!/bin/bash
echo "Starting system..."
for i in {1..10}; do
  echo "Loading module $i"
  sleep 0.1
done
echo "System ready."
                        </pre>
                    </div>
                    
                    <div class="terminal-element code-block-3 size-small">
                        <pre class="code-text">
$ ps aux
$ top -n 1
$ df -h
                        </pre>
                    </div>
                    
                    <div class="terminal-element code-block-4 size-medium">
                        <pre class="code-text">
function init() {
  console.log('Init');
  return true;
}
                        </pre>
                    </div>
                    
                    <div class="terminal-element code-block-5 size-small">
                        <pre class="code-text">
$ git status
$ npm start
                        </pre>
                    </div>
                    
                    <!-- 矩阵雨元素 -->
                    <div class="terminal-element matrix-rain size-medium">
                        <div class="matrix-column">
                            <span>1</span><span>0</span><span>1</span><span>1</span>
                            <span>0</span><span>1</span><span>0</span><span>1</span>
                            <span>1</span><span>1</span><span>0</span><span>0</span>
                        </div>
                    </div>
                    
                    <div class="terminal-element matrix-rain-2 size-small">
                        <div class="matrix-column">
                            <span>A</span><span>B</span><span>C</span>
                        </div>
                    </div>
                    
                    <div class="terminal-element matrix-rain-3 size-large">
                        <div class="matrix-column">
                            <span>█</span><span>▓</span><span>▒</span><span>░</span><span>█</span>
                        </div>
                    </div>
                    
                    <div class="terminal-element matrix-rain-4 size-small">
                        <div class="matrix-column">
                            <span>X</span><span>Y</span><span>Z</span>
                        </div>
                    </div>
                    
                    <!-- 终端提示符元素 -->
                    <div class="terminal-element terminal-prompt size-large">
                        <pre class="prompt-text">
user@system:~$ ls -la
drwxr-xr-x  animations/
-rwxr-xr-x  scroll.js
-rw-r--r--  style.css
user@system:~$ █
                        </pre>
                    </div>
                    
                    <div class="terminal-element terminal-prompt-2 size-small">
                        <pre class="prompt-text">
root@server:~# whoami
root
root@server:~# _
                        </pre>
                    </div>
                    
                    <div class="terminal-element terminal-prompt-3 size-medium">
                        <pre class="prompt-text">
admin@localhost:~$ uptime
 19:30:15 up 2 days, 14:23
admin@localhost:~$ _
                        </pre>
                    </div>
                    
                    <div class="terminal-element terminal-prompt-4 size-small">
                        <pre class="prompt-text">
$ vim config.txt
$ chmod +x script.sh
                        </pre>
                    </div>
                    
                    <!-- 电路图案元素 -->
                    <div class="terminal-element circuit-pattern size-medium">
                        <div class="circuit-lines">
                            <div class="line horizontal"></div>
                            <div class="line vertical"></div>
                            <div class="node"></div>
                            <div class="node node-2"></div>
                        </div>
                    </div>
                    
                    <div class="terminal-element circuit-pattern-2 size-small">
                        <div class="circuit-lines">
                            <div class="line horizontal"></div>
                            <div class="node"></div>
                        </div>
                    </div>
                    
                    <div class="terminal-element circuit-pattern-3 size-large">
                        <div class="circuit-lines">
                            <div class="line horizontal"></div>
                            <div class="line vertical"></div>
                            <div class="line horizontal" style="top: 30%; left: 10px; width: 60px;"></div>
                            <div class="line vertical" style="left: 30%; top: 20px; height: 80px;"></div>
                            <div class="node"></div>
                            <div class="node node-2"></div>
                            <div class="node" style="top: 26px; left: 36px;"></div>
                            <div class="node" style="top: 66px; left: 26px;"></div>
                        </div>
                    </div>
                    
                    <div class="terminal-element circuit-pattern-4 size-small">
                        <div class="circuit-lines">
                            <div class="line vertical"></div>
                            <div class="node"></div>
                        </div>
                    </div>
                    
                    <!-- 进度条元素 -->
                    <div class="terminal-element progress-bars size-medium">
                        <div class="progress-container">
                            <div class="progress-label">CPU:</div>
                            <div class="progress-bar"><div class="progress-fill cpu"></div></div>
                            <div class="progress-label">RAM:</div>
                            <div class="progress-bar"><div class="progress-fill ram"></div></div>
                        </div>
                    </div>
                    
                    <div class="terminal-element progress-bars-2 size-small">
                        <div class="progress-container">
                            <div class="progress-label">NET: 45%</div>
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: 45%;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="terminal-element progress-bars-3 size-large">
                        <div class="progress-container">
                            <div class="progress-label">DISK: 82%</div>
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: 82%;"></div>
                            </div>
                            <div class="progress-label">SWAP: 23%</div>
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: 23%;"></div>
                            </div>
                            <div class="progress-label">TEMP: 67%</div>
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: 67%;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="terminal-element progress-bars-4 size-small">
                        <div class="progress-container">
                            <div class="progress-label">GPU: 91%</div>
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: 91%;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 十六进制显示元素 -->
                    <div class="terminal-element hex-display size-medium">
                        <pre class="hex-text">
0x4A 0x53 0x20
0x41 0x4E 0x49
0x4D 0x41 0x54
0x45 0x44 0x21
                        </pre>
                    </div>
                    
                    <div class="terminal-element hex-display-2 size-small">
                        <pre class="hex-text">
0xFF 0x00
0xAB 0xCD
                        </pre>
                    </div>
                    
                    <div class="terminal-element hex-display-3 size-large">
                        <pre class="hex-text">
0x48656C6C6F20576F726C64
0x54657374696E672048657820
0x44617461204475706C696361
0x74696F6E20436865636B696E
0x67205375636365737366756C
                        </pre>
                    </div>
                    
                    <div class="terminal-element hex-display-4 size-small">
                        <pre class="hex-text">
0x1A 0x2B
0x3C 0x4D
                        </pre>
                    </div>
                    
                    <!-- 系统信息显示元素 -->
                    <div class="terminal-element system-info size-medium">
                        <pre class="system-text">
SYSTEM STATUS:
├─ CPU: Intel i7
├─ RAM: 16GB DDR4
├─ GPU: NVIDIA RTX
└─ STATUS: ONLINE
                        </pre>
                    </div>
                    
                    <div class="terminal-element system-info-2 size-small">
                        <pre class="system-text">
UPTIME:
2d 14h 23m
                        </pre>
                    </div>
                    
                    <div class="terminal-element system-info-3 size-large">
                        <pre class="system-text">
╔═══════════════════════════╗
║        SYSTEM INFO        ║
╠═══════════════════════════╣
║ OS: Linux Ubuntu 22.04   ║
║ Kernel: 5.15.0-72        ║
║ Shell: bash 5.1.16        ║
║ DE: GNOME 42.5            ║
║ WM: Mutter                ║
║ Terminal: gnome-terminal  ║
╚═══════════════════════════╝
                        </pre>
                    </div>
                    
                    <!-- 网络状态元素 -->
                    <div class="terminal-element network-status size-large">
                        <pre class="network-text">
NETWORK INTERFACE:
eth0: UP, 192.168.1.100/24
wlan0: UP, 10.0.0.50/24
lo: UP, 127.0.0.1/8

CONNECTIONS: 47 active
TRAFFIC: ↑ 2.3MB/s ↓ 15.7MB/s
                        </pre>
                    </div>
                    
                    <div class="terminal-element network-status-2 size-small">
                        <pre class="network-text">
PING: 12ms
STATUS: OK
                        </pre>
                    </div>
                    
                    <!-- 日志显示元素 -->
                    <div class="terminal-element log-display size-medium">
                        <pre class="log-text">
[19:30:15] INFO: Service started
[19:30:16] WARN: Low memory
[19:30:17] INFO: Connection OK
[19:30:18] ERROR: Timeout
                        </pre>
                    </div>
                    
                    <div class="terminal-element log-display-2 size-small">
                        <pre class="log-text">
[OK] Started
[FAIL] Error
                        </pre>
                    </div>
                </div>
                
                <!-- 文字动画区域 -->
                <div class="text-animation-area">
                    <div class="animated-text-block block-1">
                        <h3 class="block-title">CONVERGE</h3>
                        <p class="block-description">Elements unite in perfect harmony</p>
                    </div>
                    
                    <div class="animated-text-block block-2">
                        <h3 class="block-title">DISPERSE</h3>
                        <p class="block-description">Breaking boundaries, expanding horizons</p>
                    </div>
                    
                    <div class="animated-text-block block-3">
                        <h3 class="block-title">TRANSFORM</h3>
                        <p class="block-description">Morphing reality through digital alchemy</p>
                    </div>
                    
                    <div class="animated-text-block block-4">
                        <h3 class="block-title">DISTORT</h3>
                        <p class="block-description">Bending space and time with code</p>
                    </div>
                    
                    <div class="animated-text-block block-5">
                        <h3 class="block-title">STRETCH</h3>
                        <p class="block-description">Extending possibilities beyond limits</p>
                    </div>
                </div>
                
                <!-- 粒子系统容器 -->
                <div class="particle-system">
                    <canvas id="particleCanvas"></canvas>
                </div>
                

                

            </div>
        </section>
    </main>

    <!-- 引入必要的库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="./cannon.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    
    <script>
        // 注册GSAP插件
        gsap.registerPlugin(ScrollTrigger);
        
        // 终端打字效果
        function initTerminalEffect() {
            const subtitle = document.getElementById('terminalSubtitle');
            const baseText = 'VIBING CODING';
            let gCount = 0;
            let isAdding = true;
            let lastUpdate = 0;
            
            function updateTerminal() {
                const now = Date.now();
                if (now - lastUpdate < 300) return; // 控制打字速度
                lastUpdate = now;
                
                if (isAdding) {
                    gCount++;
                    if (gCount >= 8) {
                        isAdding = false;
                        setTimeout(() => {
                            isAdding = false;
                        }, 1000); // 停顿1秒后开始删除
                    }
                } else {
                    gCount--;
                    if (gCount <= 0) {
                        isAdding = true;
                        gCount = 0;
                    }
                }
                
                const gString = 'G'.repeat(Math.max(0, gCount));
                subtitle.innerHTML = baseText + gString + '<span class="cursor"></span>';
            }
            
            setInterval(updateTerminal, 300);
        }

        // 初始化应用
        document.addEventListener('DOMContentLoaded', function() {
            initHeroScene();
            initScrollAnimations();
            initTerminalEffect();
        });

        // Hero区域3D场景初始化
        function initHeroScene() {
            const canvas = document.getElementById('heroCanvas');
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                alpha: true, 
                antialias: true,
                powerPreference: "high-performance"
            });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            // 初始化物理世界
             const world = new CANNON.World();
             world.gravity.set(0, -4.9, 0); // 降低重力
             world.broadphase = new CANNON.NaiveBroadphase();
             world.defaultContactMaterial.friction = 0.4;
             world.defaultContactMaterial.restitution = 0.6; // 降低弹性
            
            // 创建边界墙体
             const boundaries = [];
             
             // 地面
             const groundShape = new CANNON.Plane();
             const groundBody = new CANNON.Body({ mass: 0 });
             groundBody.addShape(groundShape);
             groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
             groundBody.position.set(0, -8, 0);
             world.add(groundBody);
             boundaries.push(groundBody);
             
             // 左右墙
             const leftWall = new CANNON.Body({ mass: 0 });
             leftWall.addShape(new CANNON.Plane());
             leftWall.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI / 2);
             leftWall.position.set(-12, 0, 0);
             world.add(leftWall);
             
             const rightWall = new CANNON.Body({ mass: 0 });
             rightWall.addShape(new CANNON.Plane());
             rightWall.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2);
             rightWall.position.set(12, 0, 0);
             world.add(rightWall);
             
             // 前后墙
             const frontWall = new CANNON.Body({ mass: 0 });
             frontWall.addShape(new CANNON.Plane());
             frontWall.position.set(0, 0, -12);
             world.add(frontWall);
             
             const backWall = new CANNON.Body({ mass: 0 });
             backWall.addShape(new CANNON.Plane());
             backWall.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI);
             backWall.position.set(0, 0, 12);
             world.add(backWall);
             
             // 天花板
             const ceilingShape = new CANNON.Plane();
             const ceilingBody = new CANNON.Body({ mass: 0 });
             ceilingBody.addShape(ceilingShape);
             ceilingBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
             ceilingBody.position.set(0, 15, 0);
             world.add(ceilingBody);
            
            // 存储所有物体
            const objects = [];
            const bodies = [];
            const floatingObjects = [];
            const floatingBodies = [];
            const floatingOriginalPositions = [];
            
            // 创建25个几何体，增加不规则形状比例
             const geometries = [
                 new THREE.TorusKnotGeometry(0.8, 0.3, 128, 32, 2, 3),
                 new THREE.TorusKnotGeometry(0.7, 0.25, 128, 32, 3, 4),
                 new THREE.TorusKnotGeometry(0.9, 0.35, 128, 32, 5, 2),
                 new THREE.TorusKnotGeometry(0.6, 0.2, 128, 32, 4, 5),
                 new THREE.TorusKnotGeometry(0.85, 0.3, 128, 32, 3, 7),
                 new THREE.OctahedronGeometry(1.2, 6),
                 new THREE.IcosahedronGeometry(1.2, 6),
                 new THREE.DodecahedronGeometry(1.2, 6),
                 new THREE.TetrahedronGeometry(1.5, 6),
                 new THREE.TorusGeometry(1, 0.4, 64, 128),
                 new THREE.TorusGeometry(0.8, 0.3, 64, 128),
                 new THREE.TorusGeometry(1.2, 0.5, 64, 128),
                 new THREE.SphereGeometry(1, 128, 128),
                 new THREE.BoxGeometry(1.5, 1.5, 1.5, 32, 32, 32),
                 new THREE.ConeGeometry(1, 2, 128),
                 new THREE.CylinderGeometry(0.8, 0.8, 2, 128),
                 new THREE.OctahedronGeometry(1.0, 5),
                 new THREE.IcosahedronGeometry(1.0, 5),
                 new THREE.DodecahedronGeometry(1.0, 5),
                 new THREE.TetrahedronGeometry(1.3, 5),
                 new THREE.TorusKnotGeometry(0.75, 0.28, 128, 32, 6, 3),
                 new THREE.TorusKnotGeometry(0.65, 0.22, 128, 32, 7, 4),
                 new THREE.TorusKnotGeometry(0.95, 0.38, 128, 32, 2, 5),
                 new THREE.TorusGeometry(0.9, 0.35, 64, 128),
                 new THREE.SphereGeometry(0.8, 128, 128)
             ];
            
            // 创建超高质感Blender风格材质
             function createBlenderMaterial(color, metalness = 0.9, roughness = 0.1) {
                 return new THREE.MeshStandardMaterial({
                     color: color,
                     metalness: metalness,
                     roughness: roughness,
                     envMapIntensity: 2.5,
                     transparent: true,
                     opacity: 0.98,
                     clearcoat: 0.5,
                     clearcoatRoughness: 0.05,
                     sheen: 0.3,
                     sheenRoughness: 0.2,
                     sheenColor: new THREE.Color(0.2, 0.2, 0.3)
                 });
             }
            
            // 创建地面物体（原有的25个）
             for (let i = 0; i < 25; i++) {
                 const geometry = geometries[i];
                 const hue = (i / 25) * 360;
                 const material = createBlenderMaterial(
                     new THREE.Color().setHSL(hue / 360, 0.8, 0.6),
                     Math.random() * 0.2 + 0.8,
                     Math.random() * 0.15 + 0.05
                 );
                 
                 const mesh = new THREE.Mesh(geometry, material);
                 mesh.position.set(
                     (Math.random() - 0.5) * 10,
                     Math.random() * 6 + 3,
                     (Math.random() - 0.5) * 10
                 );
                 mesh.castShadow = true;
                 mesh.receiveShadow = true;
                 mesh.userData = { originalY: mesh.position.y, isHovered: false, isFloating: false };
                 scene.add(mesh);
                 objects.push(mesh);
                 
                 // 创建对应的物理体（增大尺寸）
                 const physicsShapes = [
                     new CANNON.Sphere(0.8),  // TorusKnot用球体近似
                     new CANNON.Sphere(0.7),
                     new CANNON.Sphere(0.9),
                     new CANNON.Sphere(0.6),
                     new CANNON.Sphere(0.85),
                     new CANNON.Sphere(1.2),  // Octahedron
                     new CANNON.Sphere(1.2),  // Icosahedron
                     new CANNON.Sphere(1.2),  // Dodecahedron
                     new CANNON.Sphere(1.5),  // Tetrahedron
                     new CANNON.Sphere(1),    // Torus
                     new CANNON.Sphere(0.8),
                     new CANNON.Sphere(1.2),
                     new CANNON.Sphere(1),    // Sphere
                     new CANNON.Box(new CANNON.Vec3(0.75, 0.75, 0.75)), // Box
                     new CANNON.Cylinder(1, 1, 2, 8), // Cone
                     new CANNON.Cylinder(0.8, 0.8, 2, 8), // Cylinder
                     new CANNON.Sphere(1.0),
                     new CANNON.Sphere(1.0),
                     new CANNON.Sphere(1.0),
                     new CANNON.Sphere(1.3),
                     new CANNON.Sphere(0.75),
                     new CANNON.Sphere(0.65),
                     new CANNON.Sphere(0.95),
                     new CANNON.Sphere(0.9),
                     new CANNON.Sphere(0.8)
                 ];
                 const shape = physicsShapes[i];
                 
                 const body = new CANNON.Body({ mass: 2 }); // 增加质量
                 body.addShape(shape);
                 body.position.copy(mesh.position);
                 body.material = new CANNON.Material({ friction: 0.4, restitution: 0.6 });
                 body.linearDamping = 0.4; // 添加阻尼
                 body.angularDamping = 0.4;
                 world.add(body);
                 bodies.push(body);
             }
             
             // 创建悬浮物体（15个）
             const floatingGeometries = [
                 new THREE.TorusKnotGeometry(0.6, 0.2, 64, 16, 3, 5),
                 new THREE.IcosahedronGeometry(0.8, 3),
                 new THREE.OctahedronGeometry(0.9, 3),
                 new THREE.DodecahedronGeometry(0.7, 2),
                 new THREE.TorusGeometry(0.8, 0.3, 32, 64),
                 new THREE.SphereGeometry(0.6, 64, 64),
                 new THREE.TetrahedronGeometry(1.0, 3),
                 new THREE.TorusKnotGeometry(0.5, 0.15, 64, 16, 4, 3),
                 new THREE.ConeGeometry(0.6, 1.2, 32),
                 new THREE.CylinderGeometry(0.4, 0.4, 1.0, 32),
                 new THREE.TorusKnotGeometry(0.7, 0.25, 64, 16, 2, 7),
                 new THREE.IcosahedronGeometry(0.6, 4),
                 new THREE.OctahedronGeometry(0.7, 4),
                 new THREE.TorusGeometry(0.6, 0.2, 32, 64),
                 new THREE.SphereGeometry(0.5, 64, 64)
             ];
             
             // 增加悬浮模型数量到35个，并重新分布位置
              for (let i = 0; i < 35; i++) {
                  const geometry = floatingGeometries[i % floatingGeometries.length];
                  const hue = (i / 35) * 360 + 180; // 不同的色调
                  const material = createBlenderMaterial(
                      new THREE.Color().setHSL(hue / 360, 0.7, 0.5),
                      0.8,
                      0.2
                  );
                  
                  const mesh = new THREE.Mesh(geometry, material);
                  
                  // 重新调整悬浮模型位置，在空中均匀分布
                   // 摄像头位置在(0, 5, 10)，所以模型需要在z < 10的位置
                   let x, y, z;
                   
                   // 使用球面坐标系统创建均匀分布
                   const phi = Math.acos(-1 + (2 * i) / 35); // 极角
                   const theta = Math.sqrt(35 * Math.PI) * phi; // 方位角
                   
                   // 转换为笛卡尔坐标，并调整到合适的范围
                   const radius = 8 + Math.random() * 4; // 半径 8-12
                   x = radius * Math.sin(phi) * Math.cos(theta);
                   y = 3 + radius * Math.sin(phi) * Math.sin(theta) * 0.5; // y轴压缩，保持在视野内
                   z = 2 + (radius * Math.cos(phi) + radius) * 0.25; // z轴控制在摄像头前方
                   
                   // 确保所有模型都在视野范围内
                   x = Math.max(-12, Math.min(12, x));
                   y = Math.max(1, Math.min(12, y));
                   z = Math.max(1, Math.min(8, z));
                   
                   // 根据距离中心的远近调整尺寸
                   const distanceFromCenter = Math.sqrt(x*x + (y-6)*(y-6) + (z-4)*(z-4));
                   const scaleMultiplier = 0.8 + (distanceFromCenter / 15) * 0.8; // 0.8-1.6倍
                   mesh.scale.setScalar(scaleMultiplier);
                  
                  mesh.position.set(x, y, z);
                  mesh.castShadow = true;
                  mesh.receiveShadow = true;
                  mesh.userData = { isFloating: true, isAnimating: false };
                  scene.add(mesh);
                  floatingObjects.push(mesh);
                  
                  // 记录原始位置
                  floatingOriginalPositions.push(mesh.position.clone());
                  
                  // 创建悬浮物理体（无重力影响）
                  const body = new CANNON.Body({ mass: 0 }); // 质量为0，不受重力影响
                  body.addShape(new CANNON.Sphere(0.5));
                  body.position.copy(mesh.position);
                  body.type = CANNON.Body.KINEMATIC; // 运动学物体，不受物理力影响
                  world.add(body);
                  floatingBodies.push(body);
              }
            
            // 动态高斯模糊背景
        const backgroundCanvas = document.createElement('canvas');
        backgroundCanvas.width = 512;
        backgroundCanvas.height = 512;
        const backgroundCtx = backgroundCanvas.getContext('2d');
            
            function updateBackground() {
                const time = Date.now() * 0.001;
                
                // 创建多层流动渐变
                const gradient1 = backgroundCtx.createRadialGradient(
                    256 + Math.sin(time * 0.3) * 150, 
                    256 + Math.cos(time * 0.2) * 150, 
                    0,
                    256, 256, 500
                );
                
                gradient1.addColorStop(0, `hsl(${240 + Math.sin(time * 0.15) * 30}, 80%, 18%)`);
                gradient1.addColorStop(0.2, `hsl(${260 + Math.cos(time * 0.12) * 25}, 70%, 14%)`);
                gradient1.addColorStop(0.5, `hsl(${280 + Math.sin(time * 0.08) * 20}, 60%, 10%)`);
                gradient1.addColorStop(0.8, `hsl(${220 + Math.cos(time * 0.18) * 35}, 85%, 6%)`);
                gradient1.addColorStop(1, `hsl(${200 + Math.sin(time * 0.25) * 40}, 90%, 3%)`);
                
                backgroundCtx.fillStyle = gradient1;
                backgroundCtx.fillRect(0, 0, 512, 512);
                
                // 添加第二层流动渐变
                backgroundCtx.globalCompositeOperation = 'overlay';
                const gradient2 = backgroundCtx.createLinearGradient(
                    Math.sin(time * 0.4) * 256, 0,
                    Math.cos(time * 0.4) * 256, 512
                );
                
                gradient2.addColorStop(0, `hsla(${300 + Math.sin(time * 0.1) * 20}, 60%, 8%, 0.3)`);
                gradient2.addColorStop(0.5, `hsla(${250 + Math.cos(time * 0.13) * 15}, 70%, 12%, 0.5)`);
                gradient2.addColorStop(1, `hsla(${320 + Math.sin(time * 0.17) * 25}, 50%, 5%, 0.2)`);
                
                backgroundCtx.fillStyle = gradient2;
                backgroundCtx.fillRect(0, 0, 512, 512);
                
                backgroundCtx.globalCompositeOperation = 'source-over';
                
                // 添加流动粒子效果
                backgroundCtx.globalCompositeOperation = 'screen';
                for (let i = 0; i < 20; i++) {
                    const x = (Math.sin(time * 0.1 + i) * 0.5 + 0.5) * 512;
                    const y = (Math.cos(time * 0.08 + i * 0.5) * 0.5 + 0.5) * 512;
                    const size = Math.sin(time * 0.2 + i) * 3 + 5;
                    
                    const particleGradient = backgroundCtx.createRadialGradient(x, y, 0, x, y, size);
                    particleGradient.addColorStop(0, `hsla(${240 + i * 10}, 80%, 40%, 0.1)`);
                    particleGradient.addColorStop(1, 'hsla(240, 80%, 40%, 0)');
                    
                    backgroundCtx.fillStyle = particleGradient;
                    backgroundCtx.beginPath();
                    backgroundCtx.arc(x, y, size, 0, Math.PI * 2);
                    backgroundCtx.fill();
                }
                
                backgroundCtx.globalCompositeOperation = 'source-over';
                backgroundTexture.needsUpdate = true;
            }
            
            const backgroundTexture = new THREE.CanvasTexture(backgroundCanvas);
            backgroundTexture.minFilter = THREE.LinearFilter;
            backgroundTexture.magFilter = THREE.LinearFilter;
            scene.background = backgroundTexture;
            
            // 定期更新背景和地面
            setInterval(() => {
                updateBackground();
                updateGroundWave();
            }, 50); // 更频繁的更新，更流畅的效果
            updateBackground();
            
            // 高级光照系统（调整为昏暗氛围）
            const ambientLight = new THREE.AmbientLight(0x2a2a3a, 0.2); // 进一步降低环境光
            scene.add(ambientLight);
            
            // 添加雾效果，增强深度感
            scene.fog = new THREE.Fog(0x1a1a2e, 10, 50);
            
            // 添加流动变化的地面平面
            const groundGeometry = new THREE.PlaneGeometry(50, 50, 128, 128);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a2e,
                metalness: 0.1,
                roughness: 0.9,
                transparent: true,
                opacity: 0.15, // 大幅降低透明度，几乎隐形
                fog: true,
                side: THREE.DoubleSide
            });
            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.position.y = -8;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);
            
            // 添加地面波动效果
            function updateGroundWave() {
                const time = Date.now() * 0.001;
                const positions = groundGeometry.attributes.position;
                
                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i);
                    const z = positions.getZ(i);
                    const wave = Math.sin(x * 0.1 + time) * Math.cos(z * 0.1 + time * 0.7) * 0.3;
                    positions.setY(i, wave);
                }
                
                positions.needsUpdate = true;
                groundGeometry.computeVertexNormals();
                
                // 动态调整地面颜色和透明度
                const opacity = 0.1 + Math.sin(time * 0.5) * 0.05; // 0.05-0.15之间变化
                const hue = (240 + Math.sin(time * 0.3) * 30) / 360; // 蓝紫色调变化
                groundMaterial.opacity = opacity;
                groundMaterial.color.setHSL(hue, 0.6, 0.1);
            }
            
            const directionalLight = new THREE.DirectionalLight(0x9a9aaa, 1.2);
            directionalLight.position.set(10, 15, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -25;
            directionalLight.shadow.camera.right = 25;
            directionalLight.shadow.camera.top = 25;
            directionalLight.shadow.camera.bottom = -25;
            scene.add(directionalLight);
            
            const pointLight1 = new THREE.PointLight(0x4a5c7a, 0.8, 25);
            pointLight1.position.set(-8, 8, 8);
            pointLight1.castShadow = true;
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x7a4a6b, 0.8, 25);
            pointLight2.position.set(8, 8, -8);
            pointLight2.castShadow = true;
            scene.add(pointLight2);
            
            const pointLight3 = new THREE.PointLight(0x5a7a4a, 0.6, 20);
            pointLight3.position.set(0, 12, 0);
            scene.add(pointLight3);
            
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);
            
            // 增强鼠标交互系统
             const raycaster = new THREE.Raycaster();
             const mouse = new THREE.Vector2();
             let selectedObject = null;
             let selectedBody = null;
             let isDragging = false;
             let hoveredObject = null;
             
             function onMouseMove(event) {
                 mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                 mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                 
                 // 检测悬停
                 raycaster.setFromCamera(mouse, camera);
                 const allObjects = [...objects, ...floatingObjects];
                 const intersects = raycaster.intersectObjects(allObjects);
                 
                 // 重置之前悬停的物体
                 if (hoveredObject && hoveredObject !== selectedObject) {
                     hoveredObject.userData.isHovered = false;
                 }
                 
                 // 设置新的悬停物体
                 if (intersects.length > 0 && !isDragging) {
                     hoveredObject = intersects[0].object;
                     hoveredObject.userData.isHovered = true;
                     canvas.style.cursor = 'pointer';
                 } else {
                     hoveredObject = null;
                     canvas.style.cursor = 'default';
                 }
                 
                 // 拖拽逻辑
                 if (isDragging && selectedBody) {
                     const intersectPoint = new THREE.Vector3();
                     raycaster.ray.intersectPlane(
                         new THREE.Plane(new THREE.Vector3(0, 0, 1), 0),
                         intersectPoint
                     );
                     
                     const force = new CANNON.Vec3(
                         (intersectPoint.x - selectedBody.position.x) * 25, // 降低力度
                         (intersectPoint.y - selectedBody.position.y) * 25,
                         0
                     );
                     selectedBody.applyForce(force, selectedBody.position);
                 }
             }
             
             function onMouseDown(event) {
                 mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                 mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                 
                 raycaster.setFromCamera(mouse, camera);
                 const allObjects = [...objects, ...floatingObjects];
                 const intersects = raycaster.intersectObjects(allObjects);
                 
                 if (intersects.length > 0) {
                     selectedObject = intersects[0].object;
                     const groundIndex = objects.indexOf(selectedObject);
                     const floatingIndex = floatingObjects.indexOf(selectedObject);
                     
                     if (groundIndex !== -1) {
                         // 地面物体点击效果
                         selectedBody = bodies[groundIndex];
                         isDragging = true;
                         
                         const throwForce = new CANNON.Vec3(
                             (Math.random() - 0.5) * 15,
                             Math.random() * 20 + 10,
                             (Math.random() - 0.5) * 15
                         );
                         selectedBody.applyImpulse(throwForce, selectedBody.position);
                     } else if (floatingIndex !== -1) {
                         // 悬浮物体点击效果：上下晃动
                         const floatingMesh = floatingObjects[floatingIndex];
                         const originalPos = floatingOriginalPositions[floatingIndex];
                         
                         floatingMesh.userData.isAnimating = true;
                         
                         // 创建晃动动画
                         const startTime = Date.now();
                         const animateBounce = () => {
                             const elapsed = (Date.now() - startTime) / 1000;
                             const duration = 2.0; // 动画持续2秒
                             
                             if (elapsed < duration) {
                                 const progress = elapsed / duration;
                                 const bounce = Math.sin(progress * Math.PI * 4) * Math.exp(-progress * 3);
                                 floatingMesh.position.y = originalPos.y + bounce * 3;
                                 floatingBodies[floatingIndex].position.y = floatingMesh.position.y;
                                 requestAnimationFrame(animateBounce);
                             } else {
                                 // 归位
                                 floatingMesh.position.copy(originalPos);
                                 floatingBodies[floatingIndex].position.copy(originalPos);
                                 floatingMesh.userData.isAnimating = false;
                             }
                         };
                         animateBounce();
                     }
                 }
             }
             
             function onMouseUp() {
                 selectedObject = null;
                 selectedBody = null;
                 isDragging = false;
             }
             
             canvas.addEventListener('mousemove', onMouseMove);
             canvas.addEventListener('mousedown', onMouseDown);
             canvas.addEventListener('mouseup', onMouseUp);
            
            // 添加温和的随机力和悬浮效果
             function addRandomForces() {
                 bodies.forEach((body, index) => {
                     // 降低随机力频率和强度
                     if (Math.random() < 0.005) {
                         const force = new CANNON.Vec3(
                             (Math.random() - 0.5) * 8,
                             Math.random() * 5,
                             (Math.random() - 0.5) * 8
                         );
                         body.applyForce(force, body.position);
                     }
                 });
             }
             
             // 悬浮效果
             function updateFloatingEffect() {
                 objects.forEach((obj, index) => {
                     if (obj.userData.isHovered && !isDragging) {
                         const time = Date.now() * 0.003;
                         const floatOffset = Math.sin(time + index) * 0.3;
                         const targetY = obj.userData.originalY + 1.5 + floatOffset;
                         
                         // 温和的悬浮力
                         const currentY = bodies[index].position.y;
                         const floatForce = (targetY - currentY) * 8;
                         bodies[index].applyForce(new CANNON.Vec3(0, floatForce, 0), bodies[index].position);
                     }
                 });
             }
            
            // 动画循环
            function animate() {
                requestAnimationFrame(animate);
                
                // 更新物理世界
                world.step(1/60);
                
                // 同步地面物体
                for (let i = 0; i < objects.length; i++) {
                    objects[i].position.copy(bodies[i].position);
                    objects[i].quaternion.copy(bodies[i].quaternion);
                    
                    // 动态颜色变化（更柔和的色彩）
                    const time = Date.now() * 0.001;
                    const hue = ((time * 0.05 + i * 0.067) % 1);
                    objects[i].material.color.setHSL(hue, 0.7, 0.5);
                    
                    // 边界检查，防止物体掉落太远
                 if (bodies[i].position.y < -12) {
                     bodies[i].position.set(
                         (Math.random() - 0.5) * 10,
                         Math.random() * 6 + 8,
                         (Math.random() - 0.5) * 10
                     );
                     bodies[i].velocity.set(0, 0, 0);
                     bodies[i].angularVelocity.set(0, 0, 0);
                     objects[i].userData.originalY = bodies[i].position.y;
                 }
                }
                
                // 悬浮物体的缓慢旋转和浮动
                 const floatingTime = Date.now() * 0.001;
                 for (let i = 0; i < floatingObjects.length; i++) {
                     const mesh = floatingObjects[i];
                     const originalPos = floatingOriginalPositions[i];
                     
                     // 缓慢旋转
                     mesh.rotation.x += 0.005;
                     mesh.rotation.y += 0.003;
                     mesh.rotation.z += 0.002;
                     
                     // 轻微浮动（如果没有在执行点击动画）
                     if (!mesh.userData.isAnimating) {
                         const floatOffset = Math.sin(floatingTime * 0.5 + i) * 0.5;
                         mesh.position.y = originalPos.y + floatOffset;
                         floatingBodies[i].position.copy(mesh.position);
                     }
                     
                     // 悬浮物体颜色变化
                     const hue = (i / floatingObjects.length + floatingTime * 0.03 + 0.5) % 1;
                     mesh.material.color.setHSL(hue, 0.7, 0.5);
                 }
                
                // 添加随机力和悬浮效果
                 addRandomForces();
                 updateFloatingEffect();
                
                // 相机轻微摆动
                const time = Date.now() * 0.001;
                camera.position.x = Math.sin(time * 0.5) * 2;
                camera.position.y = 5 + Math.sin(time * 0.3) * 1;
                camera.lookAt(0, 0, 0);
                
                renderer.render(scene, camera);
            }
            
            animate();
            
            // 响应式处理
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        // 滚动动画初始化
        function initScrollAnimations() {
            // Hero标题动画
            gsap.fromTo('.hero-title', 
                { y: 100, opacity: 0 },
                { y: 0, opacity: 1, duration: 1.5, ease: 'power3.out' }
            );
            
            gsap.fromTo('.hero-subtitle', 
                { y: 50, opacity: 0 },
                { y: 0, opacity: 1, duration: 1.5, delay: 0.3, ease: 'power3.out' }
            );
            
            // 滚动交互展示区动画
            initScrollInteractionAnimations();
            
            // 液态文字交互演示初始化
            initLiquidTextEffect();
        }
        
        // 滚动交互展示区动画
        function initScrollInteractionAnimations() {
            // 启用ScrollTrigger的批量更新和优化
            ScrollTrigger.config({
                autoRefreshEvents: "visibilitychange,DOMContentLoaded,load",
                ignoreMobileResize: true
            });
            
            // 添加全局滚动监听器以提高响应性
            let scrollDirection = 1;
            let lastScrollY = window.scrollY;
            
            // 使用节流函数优化滚动监听
             let scrollTimeout;
             window.addEventListener('scroll', () => {
                 const currentScrollY = window.scrollY;
                 scrollDirection = currentScrollY > lastScrollY ? 1 : -1;
                 lastScrollY = currentScrollY;
                 
                 // 清除之前的超时
                 clearTimeout(scrollTimeout);
                 
                 // 立即更新ScrollTrigger
                 ScrollTrigger.update();
                 
                 // 延迟刷新以避免过度计算
                 scrollTimeout = setTimeout(() => {
                     ScrollTrigger.refresh();
                 }, 100);
             }, { passive: true });
            // 标题区域动画
            gsap.fromTo('.scroll-title-area', {
                opacity: 0,
                y: 50,
                scale: 0.9
            }, {
                opacity: 1,
                y: 0,
                scale: 1,
                duration: 1.5,
                ease: 'power3.out',
                scrollTrigger: {
                    trigger: '.scroll-title-area',
                    start: 'top 80%',
                    end: 'top 20%',
                    scrub: true,
                    toggleActions: 'play reverse play reverse',
                    invalidateOnRefresh: true,
                    refreshPriority: -1,
                    fastScrollEnd: true,
                    preventOverlaps: true
                }
            });
            
            // 终端元素动画
            gsap.utils.toArray('.terminal-element').forEach((element, index) => {
                gsap.fromTo(element, {
                    opacity: 0,
                    scale: 0.8,
                    y: 50
                }, {
                    opacity: 1,
                    scale: 1,
                    y: 0,
                    duration: 1.2,
                    ease: 'power2.out',
                    scrollTrigger: {
                        trigger: element,
                        start: 'top 85%',
                        end: 'top 15%',
                        scrub: true,
                        toggleActions: 'play reverse play reverse',
                        invalidateOnRefresh: true,
                        refreshPriority: -1,
                        fastScrollEnd: true,
                        preventOverlaps: true
                    },
                    delay: index * 0.15
                });
                
                // 持续的浮动动画
                gsap.to(element, {
                    y: "random(-10, 10)",
                    x: "random(-5, 5)",
                    duration: "random(4, 6)",
                    ease: 'sine.inOut',
                    repeat: -1,
                    yoyo: true,
                    delay: index * 0.3
                });
                
                // 鼠标悬停时的发光效果
                element.addEventListener('mouseenter', () => {
                    gsap.to(element, {
                        scale: 1.05,
                        boxShadow: "0 0 40px rgba(0, 255, 0, 0.6), inset 0 0 30px rgba(0, 255, 0, 0.2)",
                        duration: 0.3,
                        ease: 'power2.out'
                    });
                });
                
                element.addEventListener('mouseleave', () => {
                    gsap.to(element, {
                        scale: 1,
                        boxShadow: "0 0 20px rgba(0, 255, 0, 0.3), inset 0 0 20px rgba(0, 255, 0, 0.1)",
                        duration: 0.3,
                        ease: 'power2.out'
                    });
                });
            });
            
            // 矩阵雨特殊动画 - 适用于所有矩阵雨元素
            const matrixElements = document.querySelectorAll('[class*="matrix-rain"]');
            matrixElements.forEach((matrixElement, index) => {
                ScrollTrigger.create({
                    trigger: matrixElement,
                    start: "top 80%",
                    end: "bottom 20%",
                    onEnter: () => {
                        gsap.to(matrixElement.querySelectorAll('.matrix-column span'), {
                            opacity: 1,
                            y: 0,
                            duration: 0.5,
                            stagger: 0.1,
                            ease: "power2.out",
                            delay: index * 0.2
                        });
                    },
                    onLeave: () => {
                        gsap.to(matrixElement.querySelectorAll('.matrix-column span'), {
                            opacity: 0.3,
                            duration: 0.3
                        });
                    }
                });
            });
            
            // 进度条动画 - 适用于所有进度条元素
            const progressContainers = document.querySelectorAll('[class*="progress-bars"]');
            progressContainers.forEach((container, containerIndex) => {
                const progressBars = container.querySelectorAll('.progress-fill');
                ScrollTrigger.create({
                    trigger: container,
                    start: "top 80%",
                    onEnter: () => {
                        progressBars.forEach((bar, barIndex) => {
                            let targetWidth = '60%'; // 默认宽度
                            
                            // 根据类名设置不同的宽度
                            if (bar.classList.contains('cpu')) targetWidth = '75%';
                            else if (bar.classList.contains('ram')) targetWidth = '60%';
                            else if (bar.style.width) targetWidth = bar.style.width;
                            
                            gsap.fromTo(bar, 
                                { width: '0%' },
                                { 
                                    width: targetWidth,
                                    duration: 2,
                                    delay: (containerIndex * 0.3) + (barIndex * 0.5),
                                    ease: "power2.out"
                                }
                            );
                        });
                    }
                });
            });
            
            // 文字块动画 - 不同方向的进入效果
            gsap.utils.toArray('.animated-text-block').forEach((block, index) => {
                const isEven = index % 2 === 0;
                const startX = isEven ? -150 : 150;
                
                gsap.fromTo(block, {
                    opacity: 0,
                    x: startX,
                    scale: 0.8,
                    rotation: isEven ? -15 : 15
                }, {
                    opacity: 1,
                    x: 0,
                    scale: 1,
                    rotation: 0,
                    duration: 1.5,
                    ease: 'power3.out',
                    scrollTrigger: {
                        trigger: block,
                        start: 'top 80%',
                        end: 'top 20%',
                        scrub: true,
                        toggleActions: 'play reverse play reverse',
                        invalidateOnRefresh: true,
                        refreshPriority: -1,
                        fastScrollEnd: true,
                        preventOverlaps: true
                    }
                });
                
                // 文字标题的伸展效果
                const title = block.querySelector('.block-title');
                gsap.fromTo(title, {
                    scaleX: 0.3,
                    scaleY: 1.8,
                    transformOrigin: 'center'
                }, {
                    scaleX: 1,
                    scaleY: 1,
                    duration: 1,
                    ease: 'elastic.out(1, 0.5)',
                    scrollTrigger: {
                        trigger: block,
                        start: 'top 75%',
                        end: 'top 25%',
                        scrub: true,
                        toggleActions: 'play reverse play reverse',
                        invalidateOnRefresh: true,
                        refreshPriority: -1,
                        fastScrollEnd: true,
                        preventOverlaps: true
                    },
                    delay: 0.3
                });
            });
            

            

            
            // 视差滚动效果
            gsap.utils.toArray('.graphic-element').forEach((element, index) => {
                const direction = index % 2 === 0 ? -1 : 1;
                gsap.fromTo(element, {
                    y: 0
                }, {
                    y: direction * 80 * (index % 3 + 1),
                    scrollTrigger: {
                        trigger: '.scroll-interaction-section',
                        start: 'top bottom',
                        end: 'bottom top',
                        scrub: true,
                        toggleActions: 'play reverse play reverse',
                        invalidateOnRefresh: true,
                        refreshPriority: -1,
                        fastScrollEnd: true,
                        preventOverlaps: true
                    }
                });
            });
            
            // 初始化粒子系统
            initParticleSystem();
        }
        
        // 粒子系统
        function initParticleSystem() {
            const canvas = document.getElementById('particleCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            let particles = [];
            let animationId;
            
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            class Particle {
                constructor() {
                    this.reset();
                    this.y = Math.random() * canvas.height;
                    this.opacity = Math.random() * 0.5 + 0.2;
                }
                
                reset() {
                    this.x = Math.random() * canvas.width;
                    this.y = -10;
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = Math.random() * 3 + 1;
                    this.size = Math.random() * 3 + 1;
                    this.color = `hsl(${Math.random() * 60 + 200}, 70%, 60%)`;
                    this.life = 1;
                    this.decay = Math.random() * 0.01 + 0.005;
                }
                
                update() {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.life -= this.decay;
                    
                    // 重力效果
                    this.vy += 0.05;
                    
                    // 边界检查
                    if (this.x < 0 || this.x > canvas.width || this.y > canvas.height || this.life <= 0) {
                        this.reset();
                        this.life = 1;
                    }
                }
                
                draw() {
                    ctx.save();
                    ctx.globalAlpha = this.life * this.opacity;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            // 创建粒子
            for (let i = 0; i < 50; i++) {
                particles.push(new Particle());
            }
            
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                particles.forEach(particle => {
                    particle.update();
                    particle.draw();
                });
                
                animationId = requestAnimationFrame(animate);
            }
            
            animate();
            
            // 滚动时增加粒子效果
            let lastScrollY = window.scrollY;
            window.addEventListener('scroll', () => {
                const scrollSpeed = Math.abs(window.scrollY - lastScrollY);
                if (scrollSpeed > 5) {
                    // 添加额外粒子
                    for (let i = 0; i < Math.min(scrollSpeed / 10, 5); i++) {
                        particles.push(new Particle());
                    }
                    
                    // 限制粒子数量
                    if (particles.length > 100) {
                        particles = particles.slice(-100);
                    }
                }
                lastScrollY = window.scrollY;
            });
        }
        
        // 液态文字交互效果
        function initLiquidTextEffect() {
            const canvas = document.getElementById('liquid-canvas');
            const textElement = document.getElementById('liquidText');
            const bgCanvas = document.getElementById('liquidBgCanvas');
            
            if (!canvas || !textElement || !bgCanvas) return;
            
            // 初始化动态高斯模糊背景
            initLiquidBackground(bgCanvas);
            
            function initLiquidBackground(bgCanvas) {
                const ctx = bgCanvas.getContext('2d');
                
                function resizeBgCanvas() {
                    bgCanvas.width = window.innerWidth;
                    bgCanvas.height = window.innerHeight;
                }
                resizeBgCanvas();
                
                function animateBackground() {
                    const time = Date.now() * 0.0015; // 加快动画速度
                    
                    // 清除画布
                    ctx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
                    
                    // 设置混合模式
                    ctx.globalCompositeOperation = 'source-over';
                    
                    // 基础色调 #180525
                    const baseHue = 285; // #180525 对应的色相
                    
                    // 创建多层动态渐变
                    for (let i = 0; i < 8; i++) {
                        const hueShift = Math.sin(time + i * 0.5) * 60; // 增大色相变化范围
                        const saturation = 70 + Math.sin(time * 0.4 + i) * 30; // 增强饱和度变化
                        const lightness = 20 + Math.sin(time * 0.3 + i * 0.3) * 15; // 增强亮度变化
                        
                        const x = (Math.sin(time * 0.1 + i) * 0.3 + 0.5) * bgCanvas.width;
                        const y = (Math.cos(time * 0.08 + i * 0.7) * 0.3 + 0.5) * bgCanvas.height;
                        const radius = (Math.sin(time * 0.15 + i * 0.4) * 0.2 + 0.4) * Math.min(bgCanvas.width, bgCanvas.height);
                        
                        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                        gradient.addColorStop(0, `hsla(${baseHue + hueShift}, ${saturation}%, ${lightness + 10}%, 0.6)`);
                        gradient.addColorStop(0.5, `hsla(${baseHue + hueShift * 0.7}, ${saturation * 0.8}%, ${lightness * 0.7 + 8}%, 0.3)`);
                        gradient.addColorStop(1, 'hsla(285, 60%, 15%, 0)');
                        
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
                    }
                    
                    // 添加流动粒子
                    for (let i = 0; i < 15; i++) {
                        const particleTime = time + i * 0.4;
                        const x = (Math.sin(particleTime * 0.18) * 0.5 + 0.5) * bgCanvas.width; // 加快运动速度
                        const y = (Math.cos(particleTime * 0.14) * 0.5 + 0.5) * bgCanvas.height; // 加快运动速度
                        const size = (Math.sin(particleTime * 0.3) * 0.6 + 0.6) * 100; // 增大粒子尺寸
                        
                        const hue = baseHue + Math.sin(particleTime) * 80; // 增大色相变化范围
                        const particleSat = 80 + Math.sin(particleTime * 0.5) * 20; // 动态饱和度
                        const particleLight = 40 + Math.sin(particleTime * 0.7) * 20; // 动态亮度
                        const particleGradient = ctx.createRadialGradient(x, y, 0, x, y, size);
                        particleGradient.addColorStop(0, `hsla(${hue}, ${particleSat}%, ${particleLight}%, 0.5)`);
                        particleGradient.addColorStop(1, 'hsla(285, 70%, 25%, 0)');
                        
                        ctx.fillStyle = particleGradient;
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    requestAnimationFrame(animateBackground);
                }
                
                animateBackground();
                
                window.addEventListener('resize', resizeBgCanvas);
            }
            
            // Three.js 场景设置
            const scene = new THREE.Scene();
            const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            const renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                alpha: true,
                antialias: true
            });
            
            // 响应式设置
            function updateSize() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                renderer.setSize(width, height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            }
            updateSize();
            
            // 创建文字纹理
            function createTextTexture() {
                const textCanvas = document.createElement('canvas');
                const ctx = textCanvas.getContext('2d');
                
                // 高分辨率设置
                const scale = 2;
                textCanvas.width = 2048 * scale;
                textCanvas.height = 1024 * scale;
                ctx.scale(scale, scale);
                
                // 文字样式
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 120px Technonomicon, monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // 绘制文字
                const lines = ['DISSOLVE', 'YOURSELF'];
                lines.forEach((line, index) => {
                    ctx.fillText(line, textCanvas.width / (2 * scale), 
                        (textCanvas.height / (2 * scale)) + (index - 0.5) * 150);
                });
                
                return new THREE.CanvasTexture(textCanvas);
            }
            
            // 着色器材质
            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;
            
            const fragmentShader = `
                uniform float uTime;
                uniform vec2 uMouse;
                uniform sampler2D uTexture;
                uniform float uDissolveRadius;
                uniform float uDissolveStrength;
                varying vec2 vUv;
                
                // 噪声函数
                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }
                
                float noise(vec2 st) {
                    vec2 i = floor(st);
                    vec2 f = fract(st);
                    float a = random(i);
                    float b = random(i + vec2(1.0, 0.0));
                    float c = random(i + vec2(0.0, 1.0));
                    float d = random(i + vec2(1.0, 1.0));
                    vec2 u = f * f * (3.0 - 2.0 * f);
                    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
                }
                
                void main() {
                    vec2 uv = vUv;
                    
                    // 鼠标距离计算
                    float mouseDistance = distance(uv, uMouse);
                    float dissolveEffect = smoothstep(uDissolveRadius, 0.0, mouseDistance);
                    
                    // 噪声驱动的溶解效果
                    float noiseValue = noise(uv * 8.0 + uTime * 0.5);
                    float dissolve = dissolveEffect * uDissolveStrength;
                    
                    // UV扭曲
                    vec2 distortion = vec2(
                        sin(uTime * 2.0 + uv.y * 10.0) * dissolve * 0.1,
                        cos(uTime * 1.5 + uv.x * 8.0) * dissolve * 0.1
                    );
                    
                    vec2 distortedUV = uv + distortion;
                    
                    // 采样纹理
                    vec4 textColor = texture2D(uTexture, distortedUV);
                    
                    // 溶解边缘效果
                    float alpha = textColor.a;
                    alpha *= (1.0 - dissolve * (noiseValue * 0.8 + 0.2));
                    
                    // 颜色变化
                    vec3 color = textColor.rgb;
                    color = mix(color, vec3(0.2, 0.8, 1.0), dissolve * 0.3);
                    
                    gl_FragColor = vec4(color, alpha);
                }
            `;
            
            // 创建材质和几何体
            const textTexture = createTextTexture();
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uMouse: { value: new THREE.Vector2(0.5, 0.5) },
                    uTexture: { value: textTexture },
                    uDissolveRadius: { value: 0.15 },
                    uDissolveStrength: { value: 1.0 }
                },
                vertexShader,
                fragmentShader,
                transparent: true
            });
            
            const geometry = new THREE.PlaneGeometry(2, 2);
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            
            // 鼠标交互
            const mouse = new THREE.Vector2();
            let isMouseOver = false;
            
            function onMouseMove(event) {
                mouse.x = event.clientX / window.innerWidth;
                mouse.y = 1.0 - (event.clientY / window.innerHeight);
                material.uniforms.uMouse.value.set(mouse.x, mouse.y);
                isMouseOver = true;
            }
            
            function onMouseLeave() {
                isMouseOver = false;
            }
            
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseleave', onMouseLeave);
            
            // 动画循环
            function animate() {
                requestAnimationFrame(animate);
                
                const time = performance.now() * 0.001;
                material.uniforms.uTime.value = time;
                
                // 平滑的溶解强度过渡
                const targetStrength = isMouseOver ? 1.0 : 0.0;
                material.uniforms.uDissolveStrength.value += 
                    (targetStrength - material.uniforms.uDissolveStrength.value) * 0.05;
                
                renderer.render(scene, camera);
            }
            
            animate();
            
            // 显示文字元素作为备用
            setTimeout(() => {
                textElement.style.opacity = '0.1';
            }, 100);
            
            // 窗口大小变化处理
            window.addEventListener('resize', updateSize);
        }
    </script>
</body>
</html>